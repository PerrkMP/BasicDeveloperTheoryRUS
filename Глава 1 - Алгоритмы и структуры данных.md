# Глава 1. Алгоритмы и структуры данных.
*Изучаем основные аглоритмы (сортировка, поиск, графы) и структуры данных (массивы, списки, стеки, очереди, деревья, хеш-таблицы).*
---

Алгоритмы
---

Алгоритмы являются ключевым понятием в области программирования и компьютерных наук. Они представляют собой последовательность шагов или инструкций, которые выполняются для решения определенной задачи или достижения определенной цели. Алгоритмы могут быть применены в различных областях, таких как сортировка данных, поиск информации, оптимизация задач, графические алгоритмы и многое другое.

**Основные характеристики алгоритмов:**

1. **Корректность**: Алгоритм должен решать задачу или достигать поставленной цели с правильными результатами.
2. **Эффективность**: Алгоритм должен выполняться за разумное время и использовать разумное количество ресурсов, таких как память и процессорное время.
3. **Масштабируемость**: Алгоритм должен быть способен работать с различными размерами входных данных и обрабатывать их эффективно.

**Некоторые из наиболее известных и широко используемых алгоритмов:**
- Сортировка
- Поиск
- Графы
- Динамическое программирование

## Сортировка
**Сортировка** - это процесс упорядочивания элементов в некоторой последовательности или коллекции по определенному критерию. 
Она является одной из фундаментальных операций в области алгоритмов и часто используется для улучшения эффективности поиска, 
сравнения и обработки данных. 
Сортировка имеет широкий спектр применений в различных задачах, таких как:
- Поиск наибольшего или наименьшего элемента в массиве.
- Упорядочивание данных для более эффективного поиска (например, бинарного поиска).
- Построение рейтинговых списков или таблиц.
- Обработка данных в алгоритмах машинного обучения.
- Подготовка данных для последующей обработки или анализа.
### Сортировка пузырьком (Bubble Sort)
Это, наверное, одна из самых популярных сортировок, которые многие помнят ещё со школы.
Суть проста: пары соседних элементов сравниваются и меняются местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока не будет достигнут правильный порядок. Критерии для "правильного" и "неправильного" порядка определяет разработчик. Для простоты, в данном и последующих примерах мы будем сортировать целые числа по возрастанию.
#### Python
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```
#### Java
```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```
### Сортировка выбором (Selection Sort)
На каждом шаге находится минимальный (или максимальный) элемент и меняется местами с первым неотсортированным элементом.
#### Python
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```
#### Java
```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```
### Быстрая сортировка (Quick Sort)
Выбирается опорный элемент (pivot), и элементы массива переставляются таким образом, чтобы все элементы, меньшие пивота, находились перед ним, а большие или равные - после. Процесс повторяется рекурсивно для каждой половины массива.
#### Python
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```
#### Java
```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```
### Сортировка слиянием (Merge Sort)
Эффективный алгоритм сортировки, который основывается на принципе "разделяй и сливай". Он разбивает массив на равные (или примерно равные) половины, рекурсивно сортирует каждую половину, а затем объединяет их в упорядоченный результат.

Принцип работы сортировки слиянием:

1. **Разделение**: Исходный массив рекурсивно разделяется на половины, пока каждая половина не будет состоять из одного элемента (это базовый случай).
2. **Слияние**: После разделения происходит слияние половин в упорядоченный массив. Для этого сравниваются элементы из двух половин и помещается меньший (или больший, в зависимости от порядка сортировки) элемент в результирующий массив. Этот процесс повторяется, пока все элементы не будут объединены.
3. **Возврат**: Полученный упорядоченный массив возвращается как результат сортировки.

Алгоритм сортировки слиянием можно описать следующим образом:

1. _Если размер массива меньше или равен 1, то считается, что он уже упорядочен._
2. _Разделить массив на две половины._
3. _Рекурсивно применить сортировку слиянием к каждой половине._
4. _Слить две отсортированные половины в один упорядоченный массив. Для этого сравниваются элементы из каждой половины и помещается меньший (или больший) элемент в результирующий массив. Если одна из половин закончилась, то оставшиеся элементы из другой половины просто добавляются в конец результирующего массива._
5. _Вернуть упорядоченный массив._
#### Python
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    return merge(merge_sort(left), merge_sort(right))

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
#### Java
```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for (int i = 0; i < n1; ++i) {
            L[i] = arr[left + i];
        }
        for (int j = 0; j < n2; ++j) {
            R[j] = arr[mid + 1 + j];
        }
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    int i = 0;
    int j = 0;
    int k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```
### Сортировка кучей (Heap Sort)
Создается **двоичная куча** (binary heap) из массива, а затем извлекается наибольший (или наименьший) элемент, который затем помещается в отсортированную часть массива. Процесс повторяется до полного упорядочивания.

**Двоичная куча (binary heap)** - это специальная структура данных, которая представляет собой полное двоичное дерево, удовлетворяющее основному свойству кучи. Куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева.

Основное свойство двоичной кучи (в мин-куче) заключается в том, что значение каждого узла не меньше (или не больше) значения его дочерних узлов. То есть, для любого узла i со значением A[i], узлы 2i+1 и 2i+2 (левый и правый дочерние узлы соответственно) должны иметь значения, не меньшие (или не большие) чем A[i].

*A[i] обозначает элемент массива A с индексом i*

> В контексте алгоритмов сортировки и построения кучи, A[i] обычно представляет значение элемента массива, с которым мы работаем при выполнении определенных операций, таких как сравнение или перестановка элементов.
Для простоты рассмотрим примеры с **мин-кучей**.

**Мин-куча (min-heap)** является специальным типом двоичной кучи, в которой каждый узел имеет значение, которое не меньше значений его дочерних узлов.

Основные свойства мин-кучи:

1. Свойство кучи: Значение каждого узла не меньше значений его дочерних узлов. То есть, для любого узла i со значением A[i], значения A[2i+1] (левый дочерний узел) и A[2i+2] (правый дочерний узел) не превышают A[i].
2. Полнота: Двоичная куча является полным двоичным деревом, то есть все уровни заполнены узлами, за исключением, возможно, последнего уровня, который заполняется слева направо без пропусков.

Мин-куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева. Нумерация элементов начинается с 0.

> Дерево - это связный граф без циклов. Каждая вершина имеет только одного родителя, кроме корневой вершины, которая не имеет родителя.

Пример мин-кучи:
```
        2
       / \
      4   5
     / \ 
    9   8 
```
В этом примере, значение каждого узла не меньше значений его дочерних узлов. Например, значение узла 2 не меньше значений его дочерних узлов 4 и 5. Аналогично, значение узла 4 не меньше значений его дочерних узлов 9 и 8.
Создание двоичной кучи включает в себя следующие шаги:

1. **Инициализация массива**: Создается массив, который будет представлять двоичную кучу. В этом массиве будут храниться элементы, которые необходимо упорядочить.
2. **Вставка элементов**: Элементы последовательно вставляются в массив. При вставке элемента, он сравнивается с родительским элементом и, если он меньше (или больше, в зависимости от типа кучи), то они меняются местами. Затем проверяется свойство кучи для предыдущего родительского узла, и процесс повторяется до корня дерева.
3. **Построение кучи**: После вставки всех элементов в массив, производится процедура называемая "построение кучи" (heapify). Эта процедура перестраивает массив таким образом, чтобы он удовлетворял свойству двоичной кучи. Начиная с последнего уровня дерева и двигаясь вверх, каждый узел проверяется на соответствие свойству кучи и, если это свойство нарушено, происходит перестроение кучи путем перестановки узлов.
4. **Использование кучи**: После построения кучи, наибольший (или наименьший) элемент находится в корне дерева (первый элемент массива). Этот элемент можно извлечь из кучи, а затем повторить процесс перестроения кучи для оставшихся элементов, чтобы получить следующий наибольший (или наименьший) элемент. Этот процесс можно повторять до полной сортировки массива.

#### Python
```python
def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```
#### Java
```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);
        }
    }

    public static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```
Таким образом, двоичная куча позволяет эффективно упорядочивать данные и обеспечивает быстрый доступ к наименьшему (или наибольшему) элементу. Она находит широкое применение в различных алгоритмах сортировки и приоритетных очередях.

## Поиск

Поиск является одной из основных операций в программировании и используется для нахождения определенного элемента или информации в наборе данных. Он широко применяется во множестве задач, таких как поиск элемента в массиве, нахождение определенного значения в структурах данных, фильтрация данных и многое другое.

**Некоторые примеры задач, которые можно решить с помощью поиска:**
1. **Поиск элемента в массиве**: Найти индекс элемента в заданном массиве или определить, содержится ли элемент в массиве.
2. **Бинарный поиск**: Работает для отсортированного массива и позволяет быстро находить элемент, разделяя массив на половины и исключая половину элементов на каждом шаге.
3. **Поиск в тексте**: Найти все вхождения определенного слова или подстроки в текстовом документе.
4. **Поиск пути в графе**: Найти кратчайший путь или определенный маршрут между двумя узлами в графе.
5. **Поиск наилучшего решения**: Используется в различных оптимизационных задачах, чтобы найти наилучшее решение из возможных вариантов.

### Линейный поиск

В алгоритме линейного поиска мы последовательно перебираем каждый элемент в наборе данных до тех пор, пока не найдем целевой элемент или не пройдем по всем элементам. Если элемент найден, мы возвращаем его индекс, в противном случае возвращаем _-1_, чтобы указать, что элемент не найден.

#### Python
```python
def linear_search(array, target):
    for i, element in enumerate(array):
        if element == target:
            return i
    return -1

# Пример использования
arr = [4, 2, 7, 1, 9, 5]
target_element = 7
index = linear_search(arr, target_element)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class LinearSearch {
    public static int linearSearch(int[] array, int target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == target) {
                return i;
            }
        }
        return -1;
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {4, 2, 7, 1, 9, 5};
        int targetElement = 7;
        int index = linearSearch(arr, targetElement);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int linearSearch(int array[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;
}

// Пример использования
int main() {
    int arr[] = {4, 2, 7, 1, 9, 5};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = linearSearch(arr, size, targetElement);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Бинарный поиск

При выполнении бинарного поиска, мы проверяем средний элемент в массиве, и, если он равен целевому значению, возвращаем его индекс. Если же средний элемент больше целевого значения, рекурсивно выполняем бинарный поиск в левой половине массива, иначе - рекурсивно выполняем бинарный поиск в правой половине массива. Повторяем данные действия, пока не найдем целевой элемент или не определим, что его нет в массиве.

> Напоминаю, что бинарный поиск можно выполнять только в заранее отсортированном массиве.

#### Python
```python
def binary_search(array, target, low, high):
    if low > high:
        return -1

    mid = (low + high) // 2

    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return binary_search(array, target, low, mid - 1)
    else:
        return binary_search(array, target, mid + 1, high)

# Пример использования
arr = [1, 2, 4, 5, 7, 9]
target_element = 7
index = binary_search(arr, target_element, 0, len(arr) - 1)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class BinarySearch {
    public static int binarySearch(int[] array, int target, int low, int high) {
        if (low > high) {
            return -1;
        }

        int mid = (low + high) / 2;

        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            return binarySearch(array, target, low, mid - 1);
        } else {
            return binarySearch(array, target, mid + 1, high);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {1, 2, 4, 5, 7, 9};
        int targetElement = 7;
        int index = binarySearch(arr, targetElement, 0, arr.length - 1);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int binarySearch(int array[], int target, int low, int high) {
    if (low > high) {
        return -1;
    }

    int mid = (low + high) / 2;

    if (array[mid] == target) {
        return mid;
    } else if (array[mid] > target) {
        return binarySearch(array, target, low, mid - 1);
    } else {
        return binarySearch(array, target, mid + 1, high);
    }
}

// Пример использования
int main() {
    int arr[] = {1, 2, 4, 5, 7, 9};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = binarySearch(arr, targetElement, 0, size - 1);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Поиск в тексте

**Поиск в тексте** - это процесс нахождения искомой подстроки или шаблона в заданном текстовом документе или строке. Этот алгоритм широко используется в различных приложениях, включая обработку естественного языка, поиск информации, фильтрацию данных и другие.

Существуют различные алгоритмы поиска в тексте. Мы разберем алгоритмы Рабина-Карпа (Rabin-Karp) и Кнута-Морриса-Пратта (Knuth-Morris-Pratt, KMP).

**Алгоритм Рабина-Карп:**

1. Вычисление хеша шаблона и первой подстроки текста:

    - Вычисляем хеш шаблона (pattern_hash) и хеш первой подстроки текста (text_hash) с помощью выбранной хеш-функции.
    - Сравниваем pattern_hash и text_hash. Если они совпадают, выполняем дополнительную проверку, так как возможно возникновение _коллизий_.

> Коллизия - это ситуация, когда двум различным значениям или объектам соответствует одно и то же значение хеша. В контексте поиска подстроки с использованием алгоритма Рабина-Карпа, коллизия может возникнуть, когда хеши совпадают, но сами подстроки не совпадают.

> В алгоритме Рабина-Карпа, при возникновении коллизии (совпадении хеш-значений), выполняется дополнительная проверка путем сравнения подстроки с шаблоном, чтобы убедиться в наличии точного совпадения.

2. Поиск в тексте:

    - Итерируемся по тексту с позиции 0 до (n - m), где n - длина текста, m - длина шаблона.
    - Если хеши совпадают, выполняем точное сравнение подстроки с шаблоном.
    - Если совпадение найдено, выполняем необходимые действия (например, выводим индекс вхождения).

#### Python
```python
def rabin_karp(text, pattern):
    n = len(text)
    m = len(pattern)
    pattern_hash = hash(pattern)
    for i in range(n - m + 1):
        if hash(text[i:i + m]) == pattern_hash and text[i:i + m] == pattern:
            print("Pattern found at index", i)

text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
rabin_karp(text, pattern)
```
#### Java
```java
public class RabinKarpAlgorithm {
    public void rabinKarp(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        long patternHash = pattern.hashCode();
        for (int i = 0; i <= n - m; i++) {
            if (text.substring(i, i + m).hashCode() == patternHash && text.substring(i, i + m).equals(pattern)) {
                System.out.println("Pattern found at index " + i);
            }
        }
    }

    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        RabinKarpAlgorithm rabinKarp = new RabinKarpAlgorithm();
        rabinKarp.rabinKarp(text, pattern);
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void rabinKarp(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();
    size_t patternHash = hash<string>{}(pattern);
    for (int i = 0; i <= n - m; i++) {
        if (hash<string>{}(text.substr(i, m)) == patternHash && text.substr(i, m) == pattern) {
            cout << "Pattern found at index " << i << endl;
        }
    }
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";
    rabinKarp(text, pattern);
    return 0;
}
```

**Алгоритм Кнута-Морриса-Пратта (Knuth-Morris-Pratt, KMP):**

Этот алгоритм эффективно находит все вхождения заданного шаблона в текст с _линейной сложностью_.

> Линейная сложность является очень хорошим свойством алгоритма, так как время выполнения растет медленно и не зависит от размера входных данных. Это делает алгоритм KMP эффективным для поиска в тексте даже при больших объемах данных.

1. Построение префиксной таблицы:

    - Инициализируем таблицу длины шаблона (pattern) нулями.
    - Устанавливаем переменные i и j в 1.
    - Пока i < длины шаблона:
        - Если pattern[i] равен pattern[j-1]:
            - Устанавливаем таблицу[i] равной j.
            - Увеличиваем i и j на 1.
        - Иначе:
            - Если j не равно 0:
                - Устанавливаем j равной таблице[j-1].
            - Иначе:
                - Устанавливаем таблицу[i] равной 0.
                - Увеличиваем i на 1.

2. Поиск в тексте:

    - Инициализируем переменные i и j в 0.
    - Пока i < длины текста:
        - Если текст[i] равен шаблон[j]:
            - Увеличиваем i и j на 1.
            - Если j равно длине шаблона:
                - Найдено вхождение шаблона в текст. Выполняем необходимые действия (например, выводим индекс вхождения).
                - Устанавливаем j равной таблице[j-1].
        - Иначе:
            - Если j не равно 0:
                - Устанавливаем j равной таблице[j-1].
            - Иначе:
                - Увеличиваем i на 1.

#### Python
```python
def build_prefix_table(pattern):
    n = len(pattern)
    table = [0] * n
    i, j = 1, 0
    while i < n:
        if pattern[i] == pattern[j]:
            table[i] = j + 1
            i += 1
            j += 1
        else:
            if j != 0:
                j = table[j - 1]
            else:
                table[i] = 0
                i += 1
    return table

def search_pattern(text, pattern):
    n = len(text)
    m = len(pattern)
    prefix_table = build_prefix_table(pattern)
    i = j = 0
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
            if j == m:
                print("Pattern found at index", i - j)
                j = prefix_table[j - 1]
        else:
            if j != 0:
                j = prefix_table[j - 1]
            else:
                i += 1

text = "ABCABCDABABCDABCDABDE"
pattern = "ABCDABD"
search_pattern(text, pattern)
```
#### Java
```java
public class KMPAlgorithm {
    private int[] buildPrefixTable(String pattern) {
        int n = pattern.length();
        int[] table = new int[n];
        int i = 1, j = 0;
        while (i < n) {
            if (pattern.charAt(i) == pattern.charAt(j)) {
                table[i] = j + 1;
                i++;
                j++;
            } else {
                if (j != 0) {
                    j = table[j - 1];
                } else {
                    table[i] = 0;
                    i++;
                }
            }
        }
        return table;
    }

    public void searchPattern(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        int[] prefixTable = buildPrefixTable(pattern);
        int i = 0, j = 0;
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == m) {
                    System.out.println("Pattern found at index " + (i - j));
                    j = prefixTable[j - 1];
                }
            } else {
                if (j != 0) {
                    j = prefixTable[j - 1];
                } else {
                    i++;
                }
            }
        }
    }

    public static void main(String[] args) {
        String text = "ABCABCDABABCDABCDABDE";
        String pattern = "ABCDABD";
        KMPAlgorithm kmp = new KMPAlgorithm();
        kmp.searchPattern(text, pattern);
    }
}
```
#### C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> buildPrefixTable(string pattern) {
    int n = pattern.length();
    vector<int> table(n);
    int i = 1, j = 0;
    while (i < n) {
        if (pattern[i] == pattern[j]) {
            table[i] = j + 1;
            i++;
            j++;
        } else {
            if (j != 0) {
                j = table[j - 1];
            } else {
                table[i] = 0;
                i++;
            }
        }
    }
    return table;
}

void searchPattern(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();
    vector<int> prefixTable = buildPrefixTable(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
            if (j == m) {
                cout << "Pattern found at index " << (i - j) << endl;
                j = prefixTable[j - 1];
            }
        } else {
            if (j != 0) {
                j = prefixTable[j - 1];
            } else {
                i++;
            }
        }
    }
}

int main() {
    string text = "ABCABCDABABCDABCDABDE";
    string pattern = "ABCDABD";
    searchPattern(text, pattern);
    return 0;
}
```

### Поиск пути в графе

Поиск пути в графе является одной из основных задач в области алгоритмов и структур данных. Он заключается в нахождении пути между двумя вершинами графа, учитывая определенные ограничения или цели.

Существует несколько классических алгоритмов для поиска пути в графе. Ниже приведены два из них - алгоритм поиска в ширину (BFS) и алгоритм поиска в глубину (DFS).

Оба алгоритма - поиск в ширину и поиск в глубину - являются классическими методами для поиска пути в графе и могут быть применены в различных задачах, таких как поиск кратчайшего пути, определение связности графа, топологическая сортировка и другие. Выбор конкретного алгоритма зависит от требований и особенностей задачи, а также от свойств графа, в котором происходит поиск пути.

> Перед тем, как мы посмотрим на реализацию алгоритмов BFS и DFS, предлагаю разобраться что такое граф.

Граф - это абстрактная математическая структура, используемая для представления связей или отношений между объектами. Он состоит из двух основных компонентов: вершин (или узлов) и ребер (или связей).

Вершины представляют отдельные элементы или сущности, которые могут быть связаны друг с другом. Например, в графе, представляющем социальную сеть, вершины могут представлять пользователей, а ребра - связи между этими пользователями (дружба, подписка и т. д.).

> Более подробно эту структуру данных мы разберем в соответствующем разделе текущей главы. Итак, вернемся к поиску пути в графе.

**Алгоритм поиска в ширину (BFS):**

Алгоритм поиска в ширину работает путем исследования графа "в ширину". Он начинает с заданной стартовой вершины и постепенно расширяется на все соседние вершины, а затем на их соседей и так далее.

**Шаги алгоритма:**

1. Создать очередь и поместить в нее стартовую вершину.
2. Создать массив посещенных вершин и пометить стартовую вершину как посещенную.
3. Пока очередь не пуста, повторять:
    - Извлечь вершину из начала очереди.
    - Для каждого соседа этой вершины, которые еще не посещены, пометить их как посещенные и добавить в очередь.
    - Если найдена искомая вершина (целевая), завершить алгоритм.

#### Python
```python
from collections import deque

# deque является эффективной реализацией очереди, поддерживающей быстрый доступ и добавление элементов как в начало, 
# так и в конец очереди. Он имеет почти константное время выполнения для основных операций, 
# таких как добавление и удаление элементов с обоих концов.

def bfs(graph, start, end):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node == end:
            return True
        if node not in visited:
            visited.add(node)
            queue.extend(graph[node])
    return False

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

start = 'A'
end = 'F'
print(bfs(graph, start, end))
```
#### Java
```java
import java.util.*;

public class BFSSearch {
    public static boolean bfs(Map<String, List<String>> graph, String start, String end) {
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        while (!queue.isEmpty()) {
            String node = queue.poll();
            if (node.equals(end)) {
                return true;
            }
            if (!visited.contains(node)) {
                visited.add(node);
                List<String> neighbors = graph.getOrDefault(node, new ArrayList<>());
                queue.addAll(neighbors);
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Map<String, List<String>> graph = new HashMap<>();
        graph.put("A", Arrays.asList("B", "C"));
        graph.put("B", Arrays.asList("D", "E"));
        graph.put("C", Collections.singletonList("F"));
        graph.put("D", Collections.emptyList());
        graph.put("E", Collections.emptyList());
        graph.put("F", Collections.emptyList());

        String start = "A";
        String end = "F";
        System.out.println(bfs(graph, start, end));
    }
}
```
#### C++
```cpp
#include <iostream>
#include <queue>
#include <unordered_set>
#include <unordered_map>
#include <vector>
using namespace std;

bool bfs(const unordered_map<string, vector<string>>& graph, const string& start, const string& end) {
    unordered_set<string> visited;
    queue<string> q;
    q.push(start);
    while (!q.empty()) {
        string node = q.front();
        q.pop();
        if (node == end) {
            return true;
        }
        if (visited.find(node) == visited.end()) {
            visited.insert(node);
            if (graph.find(node) != graph.end()) {
                const vector<string>& neighbors = graph.at(node);
                for (const string& neighbor : neighbors) {
                    q.push(neighbor);
                }
            }
        }
    }
    return false;
}

int main() {
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"D", "E"}},
        {"C", {"F"}},
        {"D", {}},
        {"E", {}},
        {"F", {}}
    };

    string start = "A";
    string end = "F";
    cout << (bfs(graph, start, end) ? "Path found" : "Path not found") << endl;

    return 0;
}
```

Вот несколько примеров задач, для которых BFS является эффективным подходом:

1. **Поиск кратчайшего пути**: BFS может использоваться для поиска кратчайшего пути между двумя вершинами в невзвешенном графе. Он гарантирует, что найденный путь будет иметь минимальное количество ребер.
2. **Поиск всех вершин на фиксированном расстоянии**: BFS позволяет найти все вершины, находящиеся на фиксированном расстоянии от стартовой вершины. Например, можно найти все вершины, находящиеся на расстоянии 2 от исходной вершины.
3. **Поиск в ширину в графе с весами**: BFS может быть использован для поиска кратчайшего пути во взвешенном графе, если все ребра имеют одинаковый вес. В этом случае BFS будет работать аналогично поиску в невзвешенном графе.
4. **Проверка связности графа**: BFS может использоваться для проверки связности графа, то есть определения, можно ли достичь одной вершины из другой.
5. **Поиск в графе без циклов**: Если граф является ациклическим (не содержит циклов), то BFS может быть использован для поиска вершин в графе с определенными свойствами или для проверки наличия определенных путей.

**Алгоритм поиска в глубину (DFS):**

Алгоритм поиска в глубину работает путем исследования графа "в глубину". Он начинает с заданной стартовой вершины и рекурсивно исследует все смежные вершины до тех пор, пока не достигнет целевой вершины или не исследует все возможные пути.

**Шаги алгоритма:**

1. Создать массив посещенных вершин и пометить стартовую вершину как посещенную.
2. Рекурсивно для каждого соседа текущей вершины:
    - Если соседняя вершина - целевая вершина, возвратить True.
    - Если соседняя вершина еще не посещена, вызвать рекурсивно функцию dfs для этой вершины.
3. Если дошли до конца рекурсии и не найдено целевой вершины, возвратить False.

#### Python
```python
def dfs(graph, current, end, visited):
    if current == end:
        return True
    visited.add(current)
    for neighbor in graph[current]:
        if neighbor not in visited:
            if dfs(graph, neighbor, end, visited):
                return True
    return False

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

start = 'A'
end = 'F'
visited = set()
print(dfs(graph, start, end, visited))
```
#### Java
```java
import java.util.*;

public class DFSSearch {
    public static boolean dfs(Map<String, List<String>> graph, String current, String end, Set<String> visited) {
        if (current.equals(end)) {
            return true;
        }
        visited.add(current);
        List<String> neighbors = graph.getOrDefault(current, new ArrayList<>());
        for (String neighbor : neighbors) {
            if (!visited.contains(neighbor)) {
                if (dfs(graph, neighbor, end, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Map<String, List<String>> graph = new HashMap<>();
        graph.put("A", Arrays.asList("B", "C"));
        graph.put("B", Arrays.asList("D", "E"));
        graph.put("C", Collections.singletonList("F"));
        graph.put("D", Collections.emptyList());
        graph.put("E", Collections.emptyList());
        graph.put("F", Collections.emptyList());

        String start = "A";
        String end = "F";
        Set<String> visited = new HashSet<>();
        System.out.println(dfs(graph, start, end, visited));
    }
}
```
#### C++
```cpp
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
using namespace std;

bool dfs(const unordered_map<string, vector<string>>& graph, const string& current, const string& end, unordered_set<string>& visited) {
    if (current == end) {
        return true;
    }
    visited.insert(current);
    if (graph.find(current) != graph.end()) {
        const vector<string>& neighbors = graph.at(current);
        for (const string& neighbor : neighbors) {
            if (visited.find(neighbor) == visited.end()) {
                if (dfs(graph, neighbor, end, visited)) {
                    return true;
                }
            }
        }
    }
    return false;
}

int main() {
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"D", "E"}},
        {"C", {"F"}},
        {"D", {}},
        {"E", {}},
        {"F", {}}
    };

    string start = "A";
    string end = "F";
    unordered_set<string> visited;
    cout << (dfs(graph, start, end, visited) ? "Path found" : "Path not found") << endl;

    return 0;
}
```

Алгоритм поиска в глубину (DFS) часто применяется для решения следующих задач:

1. **Поиск компонент связности**: DFS позволяет найти все вершины, достижимые из данной стартовой вершины. Это полезно, когда требуется определить, насколько связный граф или сеть.
2. **Проверка наличия циклов**: DFS может использоваться для обнаружения циклов в графе. Если в процессе обхода графа обнаруживается ребро, ведущее к уже посещенной вершине (кроме предыдущей), то в графе есть цикл.
3. **Топологическая сортировка**: DFS может быть использован для топологической сортировки направленного ациклического графа (DAG). _Топологическая сортировка_ определяет линейный порядок вершин графа, такой что каждое ребро идет от левой вершины к правой. Это полезно, например, при установке зависимостей между задачами или при решении задач планирования.
4. **Генерация всех возможных путей**: DFS позволяет найти все возможные пути в графе от стартовой вершины к целевой вершине или ко всем достижимым вершинам. Это полезно, когда требуется анализировать все пути или найти оптимальный путь.
5. **Решение головоломок**: DFS может быть использован для решения различных головоломок, таких как задачи на поиск выхода из лабиринта, задачи на раскраску графа и т.д.

### Поиск наилучшего решения

Поиск наилучшего решения (или оптимального решения) является задачей нахождения наилучшего возможного решения из множества доступных вариантов. Целью является минимизация или максимизация определенного критерия или функции оценки.

Для поиска наилучшего решения могут использоваться различные алгоритмы. Один из наиболее популярных алгоритмов для этой задачи - алгоритм поиска с возвратом (backtracking). Он основан на принципе систематического перебора всех возможных вариантов и откате к предыдущему шагу при достижении невозможности продолжения.

**Шаги алгоритма поиска наилучшего решения (backtracking):**

1. Определить критерий оптимальности, то есть функцию или условие, которое определяет наилучшее решение.
2. Рекурсивно рассмотреть все возможные варианты или комбинации решений.
3. На каждом шаге проверять, удовлетворяет ли текущее решение критерию оптимальности. Если удовлетворяет, сохранить это решение.
4. Если текущее решение не удовлетворяет критерию оптимальности или уже было найдено наилучшее решение, откатиться к предыдущему шагу.
5. Повторять шаги 3-4 до исследования всех возможных вариантов.

#### Python
```python
def backtrack(candidate, input):
    if is_solution(candidate, input):
        process_solution(candidate)
        return
    
    for next_candidate in generate_candidates(candidate, input):
        if is_valid(next_candidate, candidate, input):
            make_move(next_candidate, candidate, input)
            backtrack(next_candidate, input)
            undo_move(next_candidate, candidate, input)
```
#### Java
```java
void backtrack(int[] candidate, int[] input) {
    if (isSolution(candidate, input)) {
        processSolution(candidate);
        return;
    }
    
    int[] nextCandidates = generateCandidates(candidate, input);
    for (int nextCandidate : nextCandidates) {
        if (isValid(nextCandidate, candidate, input)) {
            makeMove(nextCandidate, candidate, input);
            backtrack(nextCandidate, input);
            undoMove(nextCandidate, candidate, input);
        }
    }
}
```
#### C++
```cpp
void backtrack(vector<int>& candidate, const vector<int>& input) {
    if (isSolution(candidate, input)) {
        processSolution(candidate);
        return;
    }
    
    vector<int> nextCandidates = generateCandidates(candidate, input);
    for (int nextCandidate : nextCandidates) {
        if (isValid(nextCandidate, candidate, input)) {
            makeMove(nextCandidate, candidate, input);
            backtrack(nextCandidate, input);
            undoMove(nextCandidate, candidate, input);
        }
    }
}
```

Алгоритм поиска наилучшего решения с использованием метода backtracking является общим подходом и может быть применен в различных задачах, таких как комбинаторные задачи, задачи о раскраске, задачи о поиске маршрутов и другие.

## Графы

**Граф** - это абстрактная математическая структура, используемая для представления связей или отношений между объектами. Он состоит из двух основных компонентов: вершин (или узлов) и ребер (или связей).

**Вершины** представляют отдельные элементы или сущности, которые могут быть связаны друг с другом. Например, в графе, представляющем социальную сеть, вершины могут представлять пользователей, а ребра - связи между этими пользователями (дружба, подписка и т. д.).

**Ребра** определяют отношения или связи между вершинами. Они могут быть направленными (ориентированными), когда имеется определенное направление движения от одной вершины к другой, или неориентированными, когда связь между вершинами является двусторонней и не имеет направления.

Графы широко применяются в различных областях, таких как информатика, сетевые технологии, социальные науки, логистика и другие. Они позволяют анализировать и моделировать различные виды связей и взаимодействий между объектами.

Существуют различные типы графов в зависимости от их свойств и характеристик. **Некоторые из них включают:**

1. **Ориентированный граф:** каждое ребро имеет направление.

```
A -> B
^    |
|    v
D <- C
```

В данном примере граф содержит четыре вершины: **_A_**, **_B_**, **_C_** и **_D_**. Ребра указывают направление связи между вершинами. Например, есть ребро, идущее от вершины **_A_** к вершине **_B_**, обозначаемое стрелкой **->**. Также есть ребро, идущее от вершины **_B_** к вершине **_C_**. Из вершины **_C_** ребро идет в вершину **_D_**, а из вершины **_D_** ребро указывает обратно на вершину **_A_**.

Здесь можно заметить, что граф образует **цикл**: путь, проходящий через вершины **_A_**, **_B_**, **_C_** и **_D_**, замыкается обратно на вершину **_A_**.

2. **Неориентированный граф:** ребра не имеют направления.

```
      A
     / \
    B---C---D
    |      /
    |     /
    E----F
```

В данном примере граф содержит шесть вершин _(A, B, C, D, E, F)_ и восемь ребер, обозначенных линиями. Каждая линия представляет связь между двумя вершинами.

**Например, в графе:**

- Вершина **_A_** связана с вершинами **_B_** и **_C_**.
- Вершина **_B_** связана с вершинами **_A_** и **_C_**.
- Вершина **_C_** связана с вершинами **_A_**, **_B_**, **_D_** и **_F_**.
- Вершина **_D_** связана с вершинами **_C_** и **_F_**.
- Вершина **_E_** связана с вершиной **_F_**.
- Вершина **_F_** связана с вершинами **_C_**, **_D_** и **_E_**.

Это пример неориентированного графа, поскольку ребра не имеют направления, и связи между вершинами являются двусторонними.

3. **Взвешенный граф:** каждому ребру присвоено числовое значение (вес).

> Поскольку изобразить взвешенный граф средствами, которые я сейчас имею, достаточно проблематично, я могу предоставить вам пример представления взвешенного графа в виде списка смежности на Python. А за одно разберемся что такое **список смежностей**.

**Список смежности** - это один из способов представления графа в виде структуры данных. Он используется для хранения информации о связях между вершинами графа.

В списке смежности каждая вершина графа представляется в виде элемента списка или массива, а каждый элемент содержит список соседних вершин, с которыми данная вершина имеет ребра или связи. Таким образом, каждый элемент списка смежности представляет вершину графа и ее соседей.

**Граф:**

```
A --- B --- C
```

**Список смежности для этого графа будет выглядеть следующим образом:**

```
{
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
```

В этом примере вершина **_A_** имеет соседа **_B_**, вершина **_B_** имеет соседей **_A_** и **_C_**, а вершина **_C_** имеет соседа **_B_**. Таким образом, список смежности позволяет легко определить, с какими вершинами связана каждая вершина графа.

> Итак, вернемся к представлению взвешенного графа.

**Представления взвешенного графа в виде списка смежности на Python:**

```Python
graph = {
    'A': [('B', 5), ('C', 2)],
    'B': [('D', 3), ('E', 7)],
    'C': [('F', 4)],
    'D': [('G', 2)],
    'E': [('H', 1)],
    'F': [],
    'G': [],
    'H': []
}
```

В данном примере граф состоит из вершин **_A_**, **_B_**, **_C_**, **_D_**, **_E_**, **_F_**, **_G_** и **_H_**. Ребра между вершинами имеют указанные веса, например, ребро между вершинами **_A_** и **_B_** имеет вес 5, ребро между вершинами **_B_** и **_D_** имеет вес 3 и так далее.

4. **Невзвешенный граф:** ребра не имеют числовых значений.

```
      A
     / \
    B---C
   / \ / \
  D---E---F
```

В этом графе есть шесть вершин, обозначенных буквами **_A_**, **_B_**, **_C_**, **_D_**, **_E_** и **_F_**. Ребра между вершинами указывают на связи между ними. Например, есть ребро между вершинами **_A_** и **_B_**, а также между **_B_** и **_C_**. Граф является неориентированным, поэтому связи между вершинами двусторонние.

5. **Связный граф:** существует путь между любыми двумя вершинами графа.

```
     A --- B
    / \   / \
   /   \ /   \
  C --- D --- E
   \   / \   /
    \ /   \ /
     F --- G
```

В этом примере граф состоит из вершин **_A_**, **_B_**, **_C_**, **_D_**, **_E_**, **_F_** и **_G_**, связанных ребрами. Все вершины графа соединены, и между любыми двумя вершинами существует путь. Это связный граф, так как нет изолированных вершин или компонентов, которые не соединены друг с другом.

6. **Дерево:** связный граф без циклов.

```
      A
    /   \
   B     C
  / \   / \
 D   E F   G
```

В данном примере **_A_** является корневой вершиной дерева, а каждая буква представляет отдельную вершину. Две вершины связаны ребром, если одна является родительской для другой. Например, **_B_** и **_C_** являются дочерними вершинами для **_A_**, **_D_** и **_E_** - для **_B_**, и так далее.

Обратите внимание, что дерево является связным графом без циклов. Каждая вершина имеет только одного родителя, кроме корневой вершины, которая не имеет родителя. 

## Динамическое программирование

**Динамическое программирование (Dynamic Programming)** - это метод решения задач путем разбиения их на более мелкие подзадачи и решения этих подзадач только один раз. Затем решения подзадач сохраняются и используются для решения более крупных задач. 

Таким образом, динамическое программирование позволяет избежать повторных вычислений и значительно улучшить эффективность алгоритма.

**Основные принципы динамического программирования:**

1. **Разбиение задачи на подзадачи:** Задача разбивается на более мелкие подзадачи, которые могут быть решены независимо друг от друга. При этом подзадачи обычно имеют перекрывающиеся подзадачи, то есть они могут использовать решения других подзадач.
2. **Определение зависимостей:** Зависимости между подзадачами должны быть явно определены. Это означает, что решение одной подзадачи должно быть зависимым от решений других подзадач.
3. **Сохранение и повторное использование решений:** Решения подзадач сохраняются в структуре данных (например, таблице или массиве) и повторно используются при необходимости. Это позволяет избежать повторных вычислений и существенно улучшает производительность алгоритма.

Динамическое программирование широко применяется для решения задач оптимизации, комбинаторных задач, задач на графах и других сложных задач. Некоторые известные алгоритмы, использующие динамическое программирование, включают:

### Нахождение наибольшей общей подпоследовательности _(Longest Common Subsequence)_

Данный алгоритм находит наибольшую общую подпоследовательность между двумя строками.

#### Python
```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # Восстановление наибольшей общей подпоследовательности
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            lcs.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(reversed(lcs))

# Пример использования:
s1 = "ABCDGH"
s2 = "AEDFHR"
result = longest_common_subsequence(s1, s2)
print(result)  # Вывод: "ADH"
```
#### Java
```java
public class LongestCommonSubsequence {
    public static String longestCommonSubsequence(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // Восстановление наибольшей общей подпоследовательности
        StringBuilder lcs = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                lcs.append(s1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }

        return lcs.reverse().toString();
    }

    public static void main(String[] args) {
        String s1 = "ABCDGH";
        String s2 = "AEDFHR";
        String result = longestCommonSubsequence(s1, s2);
        System.out.println(result);  // Вывод: "ADH"
    }
}
```
#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::string longestCommonSubsequence(const std::string& s1, const std::string& s2) {
    int m = s1.length();
    int n = s2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Восстановление наибольшей общей подпоследовательности
    std::string lcs;
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (s1[i - 1] == s2[j - 1]) {
            lcs.push_back(s1[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    std::reverse(lcs.begin(), lcs.end());
    return lcs;
}

int main() {
    std::string s1 = "ABCDGH";
    std::string s2 = "AEDFHR";
    std::string result = longestCommonSubsequence(s1, s2);
    std::cout << result << std::endl;  // Вывод: "ADH"
    return 0;
}
```

> Почему ADH?

Мы используем матрицу dp размером (m+1) x (n+1), где m и n - длины строк s1 и s2 соответственно.

**В данном примере, матрица dp имеет следующий вид:**

```
   | A | E | D | F | H | R |
   | 0 | 0 | 0 | 0 | 0 | 0 |
 A | 0 | 1 | 1 | 1 | 1 | 1 |
 B | 0 | 1 | 1 | 1 | 1 | 1 |
 C | 0 | 1 | 1 | 1 | 1 | 1 |
 D | 0 | 1 | 1 | 2 | 2 | 2 |
 G | 0 | 1 | 1 | 2 | 2 | 2 |
 H | 0 | 1 | 1 | 2 | 2 | 3 |
```

Здесь значение `dp[i][j]` представляет длину наибольшей общей подпоследовательности для префиксов `s1[0...i-1]` и `s2[0...j-1]`.

Изначально, первая строка и первый столбец заполняются нулями, так как при отсутствии символов в одной из строк наибольшая общая подпоследовательность будет иметь длину 0.

Затем мы проходим по всем элементам матрицы dp и заполняем их значениями, следуя следующим правилам:

- Если символы `s1[i-1]` и `s2[j-1]` совпадают, то `dp[i][j] = dp[i-1][j-1] + 1`. Это означает, что текущий символ входит в наибольшую общую подпоследовательность, и мы увеличиваем длину на 1.
- Если символы `s1[i-1]` и `s2[j-1]` **не** совпадают, то `dp[i][j]` равно максимуму из `dp[i-1][j]` и `dp[i][j-1]`. Мы выбираем максимальное значение, так как текущий символ не входит в наибольшую общую подпоследовательность.
    
После заполнения всей матрицы dp, мы можем восстановить наибольшую общую подпоследовательность, следуя обратному пути в матрице dp:

- Если `s1[i-1]` и `s2[j-1]` совпадают, то этот символ входит в наибольшую общую подпоследовательность. Мы добавляем его к результату и переходим к диагональному элементу `dp[i-1][j-1]`.
- Если `dp[i-1][j]` **больше** `dp[i][j-1]`, то переходим к элементу выше.
- Если `dp[i-1][j]` **меньше или равно** `dp[i][j-1]`, то переходим к элементу слева.
    
Таким образом, в нашем случае, начиная с элемента `dp[6][6]`, мы проходим по матрице и получаем следующий путь: 

```
(6, 6) -> (5, 5) -> (4, 4) -> (3, 3)
```

То есть, процесс восстановления наибольшей общей подпоследовательности будет выглядеть следующим образом:

- Начинаем с ячейки **_(6, 6)_** с значением **3** (`dp[6][6]`).
- Так как значение в ячейке **_(5, 6)_** (`dp[5][6]`) равно **2**, а значение в ячейке **_(6, 5)_** (`dp[6][5]`) равно **2**, мы выбираем ячейку **_(5, 6)_** и добавляем символ **"H"** к нашей наибольшей общей подпоследовательности.
- Затем мы двигаемся вверх к ячейке **_(4, 5)_** и добавляем символ **"D"**.
- Далее двигаемся вверх к ячейке **_(3, 4)_** и добавляем символ **"A"**.

Используя эти индексы, мы получаем символы из строки **s1** и формируем результат **"ADH"**, которая является наибольшей общей подпоследовательностью для строк **"ABCDGH"** и **"AEDFHR"**.

### Рюкзак _(Knapsack Problem)_

Классическая задача о рюкзаке (Knapsack Problem) заключается в выборе оптимального набора предметов для упаковки в рюкзак с ограниченной вместимостью, чтобы максимизировать общую стоимость предметов.

**Предположим, у нас есть следующие данные:**

- weights - массив, содержащий веса предметов (например, `[1, 3, 4, 5]`).
- values - массив, содержащий стоимости предметов (например, `[100, 300, 400, 500]`).
- capacity - вместимость рюкзака (например, 7).
    
Мы хотим выбрать набор предметов с максимальной общей стоимостью, при условии, что их суммарный вес не превышает вместимость рюкзака.

#### Python
```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i - 1] > j:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]])

    return dp[n][capacity]

weights = [1, 3, 4, 5]
values = [100, 300, 400, 500]
capacity = 7

max_value = knapsack(weights, values, capacity)
print("Максимальная стоимость предметов:", max_value)
```
#### Java
```java
public class Knapsack {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                if (weights[i - 1] > j) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]]);
                }
            }
        }

        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = {1, 3, 4, 5};
        int[] values = {100, 300, 400, 500};
        int capacity = 7;

        int maxValue = knapsack(weights, values, capacity);
        System.out.println("Максимальная стоимость предметов: " + maxValue);
    }
}
```
#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int knapsack(std::vector<int>& weights, std::vector<int>& values, int capacity) {
    int n = weights.size();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(capacity + 1));

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (weights[i - 1] > j) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = std::max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]]);
            }
        }
    }

    return dp[n][capacity];
}

int main() {
    std::vector<int> weights = {1, 3, 4, 5};
    std::vector<int> values = {100, 300, 400, 500};
    int capacity = 7;

    int maxValue = knapsack(weights, values, capacity);
    std::cout << "Максимальная стоимость предметов: " << maxValue << std::endl;

    return 0;
}
```

Эти примеры реализации решают задачу о рюкзаке с помощью динамического программирования. Они используют двумерный массив dp, в котором хранятся значения максимальной стоимости для каждого подмножества предметов и вместимости рюкзака. Алгоритм заполняет этот массив, постепенно увеличивая количество предметов и проверяя, что помещается в рюкзак, чтобы выбрать наиболее ценные предметы.

### Матрица кратчайших путей _(Floyd-Warshall Algorithm)_

**Алгоритм Флойда-Уоршелла (Floyd-Warshall)** предназначен для нахождения всех кратчайших путей между всеми парами вершин во взвешенном ориентированном графе. Он использует динамическое программирование для решения этой задачи. Алгоритм является алгоритмом сравнения, то есть он сравнивает расстояния между всеми парами вершин, чтобы найти кратчайшие пути.

Предположим, у нас есть граф с n вершинами и весами ребер, представленный в виде матрицы смежности. Матрица смежности представляет собой двумерный массив размером **_n_** x **_n_**, где каждый элемент `a[i][j]` содержит вес ребра между вершинами **_i_** и **_j_**. Если между вершинами **_i_** и **_j_** нет ребра, то `a[i][j]` принимает бесконечное значение или очень большое число, чтобы указать отсутствие связи.

**Алгоритм Флойда-Уоршелла выполняет следующие шаги:**

1. **Инициализация:** Создаем и инициализируем матрицу расстояний **_D_** размером **_n_** x **_n_**. Изначально она содержит веса ребер графа. Если между вершинами **_i_** и **_j_** нет ребра, то `D[i][j]` принимает бесконечное значение.
2. **Обновление матрицы расстояний:** Проходимся по всем парам вершин **_i_**, **_j_** и для каждой пары **_k_** находим более короткий путь между **_i_** и **_j_**, проходя через вершину **_k_**. Если новый путь короче текущего расстояния `D[i][j]`, то обновляем значение `D[i][j]` новым значением.
3. **Повторение шага 2:** Повторяем шаг 2 для всех пар вершин и для каждой вершины **_k_**. Проходимся по всем возможным комбинациям вершин **_i_**, **_j_**, **_k_** и обновляем матрицу расстояний **_D_** до тех пор, пока не найдены все кратчайшие пути.

По завершении алгоритма матрица расстояний **_D_** содержит все кратчайшие пути между всеми парами вершин.

**Пример матрицы смежности графа:**

```
     0    1    2    3    4
0 |  0    3   INF   7    1
1 |  8    0    2   INF  INF
2 |  5   INF   0    1   INF
3 | INF  INF  INF   0    4
4 | INF  INF  INF   2    0
```

В этом примере граф состоит из 5 вершин, обозначенных числами от 0 до 4. **Значение INF (бесконечность)** указывает отсутствие ребра между соответствующими вершинами.

#### Python
```python
INF = float('inf')

def floyd_warshall(graph):
    n = len(graph)
    dist = [[0 if i == j else INF for j in range(n)] for i in range(n)]
    
    for i in range(n):
        for j in range(n):
            dist[i][j] = graph[i][j]
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist

# Пример использования
graph = [
    [0, 3, INF, 7, 1],
    [8, 0, 2, INF, INF],
    [5, INF, 0, 1, INF],
    [INF, INF, INF, 0, 4],
    [INF, INF, INF, 2, 0]
]

result = floyd_warshall(graph)
for row in result:
    print(row)
```
#### Java
```java
public class FloydWarshall {
    private static final int INF = Integer.MAX_VALUE;

    public static int[][] floydWarshall(int[][] graph) {
        int n = graph.length;
        int[][] dist = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        return dist;
    }

    public static void main(String[] args) {
        int[][] graph = {
            {0, 3, INF, 7, 1},
            {8, 0, 2, INF, INF},
            {5, INF, 0, 1, INF},
            {INF, INF, INF, 0, 4},
            {INF, INF, INF, 2, 0}
        };

        int[][] result = floydWarshall(graph);
        for (int[] row : result) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```
#### C++
```cpp
#include <iostream>
#include <vector>

#define INF INT_MAX

std::vector<std::vector<int>> floydWarshall(const std::vector<std::vector<int>>& graph) {
    int n = graph.size();
    std::vector<std::vector<int>> dist(graph);
    
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    
    return dist;
}

int main() {
    std::vector<std::vector<int>> graph = {
        {0, 3, INF, 7, 1},
        {8, 0, 2, INF, INF},
        {5, INF, 0, 1, INF},
        {INF, INF, INF, 0, 4},
        {INF, INF, INF, 2, 0}
    };
    
    std::vector<std::vector<int>> result = floydWarshall(graph);
    for (const auto& row : result) {
        for (int val : row) {
            if (val == INF) {
                std::cout << "INF ";
            } else {
                std::cout << val << " ";
            }
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

В этих примерах граф представлен в виде матрицы смежности, и алгоритм Флойда-Уоршелла применяется для поиска кратчайших путей между всеми парами вершин. Результат выводится в виде матрицы, где каждый элемент `[i][j]` представляет собой длину кратчайшего пути от вершины **_i_** к вершине **_j_**.

### Список вопросов по теме алгоритмов, которые могут быть заданы на собеседовании уровня Middle

Вопросы в большинстве случаев будут затрагивать темы, которые мы разобрали ранее, но могут быть и другие, например:

1. _Что такое сложность алгоритма? Какие виды сложности вы знаете?_

Сложность алгоритма определяет количество ресурсов, необходимых для его выполнения, таких как время и память. Она помогает оценить, насколько эффективно работает алгоритм при увеличении размера входных данных. 

**Виды сложности включают:**

- **Временная сложность:** определяет сколько времени занимает выполнение алгоритма. Измеряется в количестве операций или временных единицах.
- **Пространственная сложность:** определяет объем памяти, необходимый для выполнения алгоритма. Измеряется в количестве используемых ячеек памяти.

2. _Что такое Big O нотация? Какие основные классы сложности вы можете назвать?_

Big O нотация используется для описания асимптотической (нарастающей) сложности алгоритма. Она указывает на его поведение при стремлении размера входных данных к бесконечности. 

**Основные классы сложности включают:**

- **O(1)** - постоянная сложность, когда время выполнения не зависит от размера входных данных.
- **O(log n)** - логарифмическая сложность, когда время выполнения растет логарифмически пропорционально размеру входных данных.
- **O(n)** - линейная сложность, когда время выполнения прямо пропорционально размеру входных данных.
- **O(n^2), O(n^3)** и т.д. - квадратичная, кубическая и другие виды сложности, когда время выполнения зависит от квадрата, куба и т.д. размера входных данных.

3. _Что такое асимптотическая сложность? Как она связана с Big O нотацией?_

Асимптотическая сложность алгоритма описывает его поведение при увеличении размера входных данных. Она позволяет сделать общий вывод о том, насколько эффективно работает алгоритм. Big O нотация используется для формального описания асимптотической сложности.

4. _Как определить время выполнения и использование памяти алгоритма?_

Определение времени выполнения и использования памяти алгоритма может быть осуществлено с помощью анализа кода и его выполнения. Можно измерить фактическое время выполнения алгоритма на разных наборах данных и использование памяти, используя специализированные инструменты или профилировщики кода.

Существует несколько инструментов и профилировщиков кода, которые помогают определить время выполнения алгоритмов и выявить узкие места в коде. **Некоторые из них включают:**

- **timeit (Python):** Встроенный модуль в Python, который позволяет измерять время выполнения небольших фрагментов кода. Он предоставляет удобный интерфейс для многократного запуска кода и измерения среднего времени выполнения.

```python
import timeit

def my_function():
    # Код, который нужно измерить

execution_time = timeit.timeit(my_function, number=1000)
print("Время выполнения:", execution_time)
```

- **System.currentTimeMillis() / System.nanoTime() (Java):** В Java вы можете использовать метод System.currentTimeMillis() или System.nanoTime() для измерения времени выполнения. Эти методы возвращают текущее время в миллисекундах или наносекундах соответственно.

```java
long startTime = System.currentTimeMillis();

// Код, который нужно измерить

long endTime = System.currentTimeMillis();
long executionTime = endTime - startTime;
System.out.println("Время выполнения: " + executionTime + " мс");
```

- **std::chrono (C++):** В C++ вы можете использовать библиотеку std::chrono для измерения времени выполнения. Она предоставляет классы и функции для работы со временем и измерения прошедшего времени.

```cpp
#include <iostream>
#include <chrono>

int main() {
    auto start = std::chrono::high_resolution_clock::now();

    // Код, который нужно измерить

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Время выполнения: " << duration.count() << " мс" << std::endl;
    return 0;
}
```

- **Профилировщики кода:**
    - **Profiler (Python):** Профилировщик встроен в стандартную библиотеку Python и позволяет измерять время выполнения и профилировать код с помощью функций profile и cProfile.
    - **VisualVM (Java):** Мощный инструмент профилирования для Java, который предоставляет детальную информацию о времени выполнения, использовании памяти и других аспектах приложения.
    - **Valgrind (C/C++):** Профилировщик и инструмент анализа памяти для C и C++, позволяющий обнаруживать утечки памяти, ошибки и оптимизировать код.

5. _Что такое рекурсия? Как она работает? Какие проблемы могут возникнуть при использовании рекурсии?_

**Рекурсия** - это процесс, при котором функция вызывает саму себя. При использовании рекурсии необходимо иметь базовый случай, чтобы остановить рекурсивные вызовы. Примером рекурсивной задачи является вычисление факториала числа. Однако, при использовании рекурсии возможны проблемы, такие как переполнение **стека вызовов** _(stack overflow)_ при слишком большой глубине рекурсии.

**Стек вызовов _(call stack)_** является одной из основных структур данных, используемых во время выполнения программы. Он представляет собой стек, где каждый элемент называется фреймом вызова (call frame) или просто фреймом. Стек вызовов отслеживает порядок вызова функций (или методов) в программе и хранит информацию о контексте каждого вызова.

Когда функция вызывается, новый фрейм вызова создается и помещается на вершину стека вызовов. Фрейм вызова содержит информацию о текущей функции, переданных аргументах, локальных переменных и адресе возврата - месте, куда вернется выполнение после завершения функции.

Стек вызовов работает по принципу _"последним пришел, первым ушел" (Last-In-First-Out, LIFO)_, что означает, что последний добавленный фрейм вызова будет первым, который будет удален при возврате из функции. Когда функция завершается, соответствующий фрейм вызова удаляется из вершины стека, и управление передается обратно к предыдущей функции.

Стек вызовов играет важную роль в процессе выполнения программы и обеспечивает корректное управление вызовами функций. Он позволяет программе отслеживать последовательность вызовов и правильно возвращаться к предыдущему контексту после завершения функции. Кроме того, стек вызовов используется для обработки исключений, а также для рекурсивных вызовов функций.

Переполнение стека вызовов возникает, когда количество вызовов функции становится слишком большим, и стек вызовов исчерпывает доступное пространство памяти. Когда это происходит, обычно возникает исключение **StackOverflowError** (в языке Java) или **RuntimeError**: maximum recursion depth exceeded (в языке Python).

Чтобы избежать переполнения стека вызовов при использовании рекурсии, необходимо принять меры предосторожности. Важно иметь базовый случай (base case), который определяет условие выхода из рекурсии. Без базового случая рекурсия будет продолжаться бесконечно, ведя к переполнению стека вызовов.

**Пример**:

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

# Вычисление факториала числа 5
result = factorial(5)
print(result)
```

В этом примере базовый случай определяется, когда **_n_** равно **_0_**, и функция возвращает **_1_**. В остальных случаях функция вызывает саму себя с аргументом **_n - 1_**, уменьшая **_n_** на каждом шаге. Это обеспечивает условие выхода из рекурсии и предотвращает переполнение стека вызовов.

6. _Что такое хеш-таблицы? Как они работают и в каких случаях их можно использовать?_

**Хеш-таблицы** - это структуры данных, которые используют хеш-функции для быстрого поиска, вставки и удаления элементов. Они основаны на идее преобразования ключа в индекс массива, где хранятся соответствующие значения. Хеш-таблицы обычно используются для реализации словарей, баз данных, кэшей и других приложений, требующих быстрого доступа к данным по ключу.

> Другие структуры данные мы разберем в следующем разделе. А сейчас предлагаю решить интересную задачу.

### Задача: Поиск оптимального маршрута в городе для доставки грузов.

У вас есть город, представленный в виде графа, где вершины - это различные места в городе (улицы, перекрестки, здания), а ребра - это дороги, связывающие эти места. Вам необходимо разработать программу, которая найдет оптимальный маршрут для доставки грузов из начального места (склада) в конечное место (пункт доставки), **учитывая следующие ограничения:**

1. Каждое место имеет определенные временные окна, в которые разрешено производить доставку. Временное окно представляет собой интервал времени, в котором разрешена доставка в данное место.
2. У каждого места есть вес груза, который нужно доставить. Некоторые места могут иметь ограничение на вес груза, который может быть доставлен.
3. У вас есть ограниченная грузоподъемность у ваших транспортных средств. Вам нужно учесть эту грузоподъемность при планировании маршрута доставки.
4. Необходимо доставить все грузы в оптимальном порядке, минимизируя время доставки и соблюдая ограничения временных окон и грузоподъемности.

**Входные данные:**

- Граф города с указанием мест и дорог между ними.
- Каждому месту сопоставлены временные окна, вес груза и грузоподъемность транспортных средств.
- Начальное и конечное места.

**Выходные данные:**

- Оптимальный маршрут доставки, указывающий порядок посещения мест.
- Время доставки, учитывающее временные окна каждого места.
- Распределение грузов по местам в рамках грузоподъемности транспортных средств.

**Алгоритм решения:**

1. **Построение графа:** Создайте граф города, где вершины представляют места, а ребра - дороги. Каждому ребру присвойте вес, соответствующий времени путешествия между местами.
2. **Сортировка:** Отсортируйте места в порядке увеличения временных окон, чтобы сначала посетить места с более ранними временными окнами.
3. **Динамическое программирование:** Используйте динамическое программирование для нахождения оптимального маршрута доставки. Создайте матрицу, где каждая ячейка представляет собой подмножество мест, которые нужно посетить, и время, потраченное на доставку до последнего места в подмножестве. Заполните матрицу, используя рекуррентную формулу, чтобы найти оптимальный маршрут и время доставки.
4. **Поиск:** Найдите оптимальный маршрут, перебирая все возможные комбинации мест и проверяя их на соответствие ограничениям временных окон и грузоподъемности. Используйте поиск в глубину или поиск в ширину для обхода графа.

**[Обсуждение задачи](https://github.com/PerrkMP/Quality-Development-RUS/issues/1)**

Структуры данных
---

**Структуры данных** - это способы организации и хранения данных в компьютерной программе. Они предоставляют эффективные методы для выполнения операций вставки, удаления и поиска данных. Каждая структура данных имеет свои преимущества и недостатки и может использоваться для решения определенных задач. Рассмотрим некоторые основные структуры данных.

### Массивы

Массивы представляют собой набор элементов одного типа, расположенных последовательно в памяти. 

- **Операции:** доступ к элементу по индексу, вставка, удаление, обход.
- **Преимущества:** быстрый доступ к элементам по индексу.
- **Недостатки:** фиксированный размер, сложности с вставкой и удалением элементов в середине массива.

Массивы являются одним из наиболее распространенных способов хранения и доступа к данным во многих языках программирования. Давайте рассмотрим подробнее массивы и примеры их использования на Python, Java и C++.

#### Python

В Python массивы можно создать с использованием встроенного типа данных `list`.

```python
# Создание массива
my_array = [1, 2, 3, 4, 5]

# Доступ к элементам массива
print(my_array[0])  # Выводит: 1
print(my_array[2])  # Выводит: 3

# Изменение значения элемента массива
my_array[1] = 10

# Длина массива
print(len(my_array))  # Выводит: 5
```

#### Java

В Java массивы являются частью языка и объявляются с указанием типа элементов и их размера.

```java
// Создание массива
int[] myArray = new int[5];  // Массив целых чисел размером 5

// Инициализация значений массива
myArray[0] = 1;
myArray[1] = 2;
myArray[2] = 3;
myArray[3] = 4;
myArray[4] = 5;

// Доступ к элементам массива
System.out.println(myArray[0]);  // Выводит: 1
System.out.println(myArray[2]);  // Выводит: 3

// Изменение значения элемента массива
myArray[1] = 10;

// Длина массива
System.out.println(myArray.length);  // Выводит: 5
```

#### C++

В C++ массивы объявляются с указанием типа элементов и их размера.

```cpp
// Создание массива
int myArray[5];  // Массив целых чисел размером 5

// Инициализация значений массива
myArray[0] = 1;
myArray[1] = 2;
myArray[2] = 3;
myArray[3] = 4;
myArray[4] = 5;

// Доступ к элементам массива
cout << myArray[0] << endl;  // Выводит: 1
cout << myArray[2] << endl;  // Выводит: 3

// Изменение значения элемента массива
myArray[1] = 10;

// Длина массива
int size = sizeof(myArray) / sizeof(myArray[0]);
cout << size << endl;  // Выводит: 5
```

Массивы являются мощным инструментом для хранения и обработки данных в программировании и широко используются для решения различных задач.

### Связанные списки

**Связанные списки** - это структура данных, состоящая из узлов, где каждый узел содержит данные и ссылку на следующий узел. Они предоставляют гибкость изменения размера и эффективность вставки и удаления элементов в середине списка.

Рассмотрим примеры реализации связанных списков на Python, Java и C++:

#### Python

```python
# Определение класса узла
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Определение класса связанного списка
class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()

# Создание и использование связанного списка
linked_list = LinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.display()
```

#### Java

```java
// Определение класса узла
class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// Определение класса связанного списка
class LinkedList {
    Node head;

    public void append(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}

// Создание и использование связанного списка
LinkedList linkedList = new LinkedList();
linkedList.append(1);
linkedList.append(2);
linkedList.append(3);
linkedList.display();
```

#### C++

```cpp
#include <iostream>

// Определение структуры узла
struct Node {
    int data;
    Node* next;

    Node(int data) : data(data), next(nullptr) {}
};

// Определение класса связанного списка
class LinkedList {
private:
    Node* head;

public:
    LinkedList() : head(nullptr) {}

    void append(int data) {
        Node* newNode = new Node(data);
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }

    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

// Создание и использование связанного списка
LinkedList linkedList;
linkedList.append(1);
linkedList.append(2);
linkedList.append(3);
linkedList.display();
```

Во всех трех примерах мы создаем связанный список и добавляем несколько элементов. Затем используем метод `display()` для вывода содержимого списка. Результатом выполнения кода будет вывод чисел _1_, _2_, _3_, представляющих содержимое связанного списка.

**Рассмотрим процесс работы со связанными списками:**

1. **Создание узла:**
   - Каждый узел содержит данные, которые нужно сохранить. Например, это может быть число, строка или любой другой объект.
   - Узел также содержит ссылку на следующий узел в списке (обычно называемую _"next"_ или _"nextNode"_).
   - Создается экземпляр узла, и данные сохраняются в нем. Затем устанавливается ссылка на следующий узел или оставляется равной `None` (или `null` в некоторых языках программирования), если это последний узел списка.
  
2. **Добавление элемента в список (вставка):**
   - Для вставки нового элемента в связанный список необходимо создать новый узел, содержащий данные, которые нужно добавить.
   - Если список пустой (т.е. `head` равен `None`), то новый узел становится головным узлом (т.е. `head` указывает на него).
   - Если список не пустой, необходимо найти последний узел (т.е. узел, у которого `next` равен `None`) и установить его `next` ссылку на новый узел.
  
3. **Удаление элемента из списка:**
   - Для удаления элемента из связанного списка необходимо найти узел, предшествующий удаляемому узлу.
   - Изменяется ссылка предыдущего узла, чтобы она указывала на следующий узел после удаляемого узла, тем самым _"обходя"_ удаляемый узел.
  
4. **Поиск элемента в списке:**
   - Поиск элемента в связанном списке происходит путем последовательного перехода от одного узла к другому, начиная с головного узла.
   - Сравниваются значения данных в узлах с искомым значением.
   - Если найдено совпадение, операция поиска завершается, и узел с искомым значением возвращается. Если нет совпадений, поиск продолжается, пока не достигнут конец списка (когда ссылка `next` равна `None`), и возвращается значение, указывающее на отсутствие элемента.

> В данных примерах не приведены все возможные операции со связанным списком, но они могут быть легко добавлены, такие как удаление элемента, вставка перед или после определенного элемента, поиск элемента и т.д.

> Попробуйте к приведенным выше примерам добавить операции удаления и поиска.
