# Глава 1. Алгоритмы и структуры данных.
*Изучаем основные аглоритмы (сортировка, поиск, графы) и структуры данных (массивы, списки, стеки, очереди, деревья, хеш-таблицы).*
---
Алгоритмы являются ключевым понятием в области программирования и компьютерных наук. Они представляют собой последовательность шагов или инструкций, которые выполняются для решения определенной задачи или достижения определенной цели. Алгоритмы могут быть применены в различных областях, таких как сортировка данных, поиск информации, оптимизация задач, графические алгоритмы и многое другое.

**Основные характеристики алгоритмов:**

1. **Корректность**: Алгоритм должен решать задачу или достигать поставленной цели с правильными результатами.
2. **Эффективность**: Алгоритм должен выполняться за разумное время и использовать разумное количество ресурсов, таких как память и процессорное время.
3. **Масштабируемость**: Алгоритм должен быть способен работать с различными размерами входных данных и обрабатывать их эффективно.

**Некоторые из наиболее известных и широко используемых алгоритмов:**
- Сортировка
- Поиск
- Графы
- Динамическое программирование

## Сортировка
**Сортировка** - это процесс упорядочивания элементов в некоторой последовательности или коллекции по определенному критерию. 
Она является одной из фундаментальных операций в области алгоритмов и часто используется для улучшения эффективности поиска, 
сравнения и обработки данных. 
Сортировка имеет широкий спектр применений в различных задачах, таких как:
- Поиск наибольшего или наименьшего элемента в массиве.
- Упорядочивание данных для более эффективного поиска (например, бинарного поиска).
- Построение рейтинговых списков или таблиц.
- Обработка данных в алгоритмах машинного обучения.
- Подготовка данных для последующей обработки или анализа.
### Сортировка пузырьком (Bubble Sort)
Это, наверное, одна из самых популярных сортировок, которые многие помнят ещё со школы.
Суть проста: пары соседних элементов сравниваются и меняются местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока не будет достигнут правильный порядок. Критерии для "правильного" и "неправильного" порядка определяет разработчик. Для простоты, в данном и последующих примерах мы будем сортировать целые числа по возрастанию.
#### Python
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```
#### Java
```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```
### Сортировка выбором (Selection Sort)
На каждом шаге находится минимальный (или максимальный) элемент и меняется местами с первым неотсортированным элементом.
#### Python
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```
#### Java
```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```
### Быстрая сортировка (Quick Sort)
Выбирается опорный элемент (pivot), и элементы массива переставляются таким образом, чтобы все элементы, меньшие пивота, находились перед ним, а большие или равные - после. Процесс повторяется рекурсивно для каждой половины массива.
#### Python
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```
#### Java
```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```
### Сортировка слиянием (Merge Sort)
Эффективный алгоритм сортировки, который основывается на принципе "разделяй и сливай". Он разбивает массив на равные (или примерно равные) половины, рекурсивно сортирует каждую половину, а затем объединяет их в упорядоченный результат.

Принцип работы сортировки слиянием:

1. **Разделение**: Исходный массив рекурсивно разделяется на половины, пока каждая половина не будет состоять из одного элемента (это базовый случай).
2. **Слияние**: После разделения происходит слияние половин в упорядоченный массив. Для этого сравниваются элементы из двух половин и помещается меньший (или больший, в зависимости от порядка сортировки) элемент в результирующий массив. Этот процесс повторяется, пока все элементы не будут объединены.
3. **Возврат**: Полученный упорядоченный массив возвращается как результат сортировки.

Алгоритм сортировки слиянием можно описать следующим образом:

1. _Если размер массива меньше или равен 1, то считается, что он уже упорядочен._
2. _Разделить массив на две половины._
3. _Рекурсивно применить сортировку слиянием к каждой половине._
4. _Слить две отсортированные половины в один упорядоченный массив. Для этого сравниваются элементы из каждой половины и помещается меньший (или больший) элемент в результирующий массив. Если одна из половин закончилась, то оставшиеся элементы из другой половины просто добавляются в конец результирующего массива._
5. _Вернуть упорядоченный массив._
#### Python
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    return merge(merge_sort(left), merge_sort(right))

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
#### Java
```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for (int i = 0; i < n1; ++i) {
            L[i] = arr[left + i];
        }
        for (int j = 0; j < n2; ++j) {
            R[j] = arr[mid + 1 + j];
        }
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    int i = 0;
    int j = 0;
    int k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```
### Сортировка кучей (Heap Sort)
Создается **двоичная куча** (binary heap) из массива, а затем извлекается наибольший (или наименьший) элемент, который затем помещается в отсортированную часть массива. Процесс повторяется до полного упорядочивания.

**Двоичная куча (binary heap)** - это специальная структура данных, которая представляет собой полное двоичное дерево, удовлетворяющее основному свойству кучи. Куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева.

Основное свойство двоичной кучи (в мин-куче) заключается в том, что значение каждого узла не меньше (или не больше) значения его дочерних узлов. То есть, для любого узла i со значением A[i], узлы 2i+1 и 2i+2 (левый и правый дочерние узлы соответственно) должны иметь значения, не меньшие (или не большие) чем A[i].

*A[i] обозначает элемент массива A с индексом i*

> В контексте алгоритмов сортировки и построения кучи, A[i] обычно представляет значение элемента массива, с которым мы работаем при выполнении определенных операций, таких как сравнение или перестановка элементов.
Для простоты рассмотрим примеры с **мин-кучей**.

**Мин-куча (min-heap)** является специальным типом двоичной кучи, в которой каждый узел имеет значение, которое не меньше значений его дочерних узлов.

Основные свойства мин-кучи:

1. Свойство кучи: Значение каждого узла не меньше значений его дочерних узлов. То есть, для любого узла i со значением A[i], значения A[2i+1] (левый дочерний узел) и A[2i+2] (правый дочерний узел) не превышают A[i].
2. Полнота: Двоичная куча является полным двоичным деревом, то есть все уровни заполнены узлами, за исключением, возможно, последнего уровня, который заполняется слева направо без пропусков.

Мин-куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева. Нумерация элементов начинается с 0.

> Дерево - это связный граф без циклов. Каждая вершина имеет только одного родителя, кроме корневой вершины, которая не имеет родителя.

Пример мин-кучи:
```
        2
       / \
      4   5
     / \ 
    9   8 
```
В этом примере, значение каждого узла не меньше значений его дочерних узлов. Например, значение узла 2 не меньше значений его дочерних узлов 4 и 5. Аналогично, значение узла 4 не меньше значений его дочерних узлов 9 и 8.
Создание двоичной кучи включает в себя следующие шаги:

1. **Инициализация массива**: Создается массив, который будет представлять двоичную кучу. В этом массиве будут храниться элементы, которые необходимо упорядочить.
2. **Вставка элементов**: Элементы последовательно вставляются в массив. При вставке элемента, он сравнивается с родительским элементом и, если он меньше (или больше, в зависимости от типа кучи), то они меняются местами. Затем проверяется свойство кучи для предыдущего родительского узла, и процесс повторяется до корня дерева.
3. **Построение кучи**: После вставки всех элементов в массив, производится процедура называемая "построение кучи" (heapify). Эта процедура перестраивает массив таким образом, чтобы он удовлетворял свойству двоичной кучи. Начиная с последнего уровня дерева и двигаясь вверх, каждый узел проверяется на соответствие свойству кучи и, если это свойство нарушено, происходит перестроение кучи путем перестановки узлов.
4. **Использование кучи**: После построения кучи, наибольший (или наименьший) элемент находится в корне дерева (первый элемент массива). Этот элемент можно извлечь из кучи, а затем повторить процесс перестроения кучи для оставшихся элементов, чтобы получить следующий наибольший (или наименьший) элемент. Этот процесс можно повторять до полной сортировки массива.

#### Python
```python
def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```
#### Java
```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);
        }
    }

    public static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```
Таким образом, двоичная куча позволяет эффективно упорядочивать данные и обеспечивает быстрый доступ к наименьшему (или наибольшему) элементу. Она находит широкое применение в различных алгоритмах сортировки и приоритетных очередях.

## Поиск

Поиск является одной из основных операций в программировании и используется для нахождения определенного элемента или информации в наборе данных. Он широко применяется во множестве задач, таких как поиск элемента в массиве, нахождение определенного значения в структурах данных, фильтрация данных и многое другое.

**Некоторые примеры задач, которые можно решить с помощью поиска:**
1. **Поиск элемента в массиве**: Найти индекс элемента в заданном массиве или определить, содержится ли элемент в массиве.
2. **Бинарный поиск**: Работает для отсортированного массива и позволяет быстро находить элемент, разделяя массив на половины и исключая половину элементов на каждом шаге.
3. **Поиск в тексте**: Найти все вхождения определенного слова или подстроки в текстовом документе.
4. **Поиск пути в графе**: Найти кратчайший путь или определенный маршрут между двумя узлами в графе.
5. **Поиск наилучшего решения**: Используется в различных оптимизационных задачах, чтобы найти наилучшее решение из возможных вариантов.

### Линейный поиск

В алгоритме линейного поиска мы последовательно перебираем каждый элемент в наборе данных до тех пор, пока не найдем целевой элемент или не пройдем по всем элементам. Если элемент найден, мы возвращаем его индекс, в противном случае возвращаем _-1_, чтобы указать, что элемент не найден.

#### Python
```python
def linear_search(array, target):
    for i, element in enumerate(array):
        if element == target:
            return i
    return -1

# Пример использования
arr = [4, 2, 7, 1, 9, 5]
target_element = 7
index = linear_search(arr, target_element)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class LinearSearch {
    public static int linearSearch(int[] array, int target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == target) {
                return i;
            }
        }
        return -1;
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {4, 2, 7, 1, 9, 5};
        int targetElement = 7;
        int index = linearSearch(arr, targetElement);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int linearSearch(int array[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;
}

// Пример использования
int main() {
    int arr[] = {4, 2, 7, 1, 9, 5};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = linearSearch(arr, size, targetElement);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Бинарный поиск

При выполнении бинарного поиска, мы проверяем средний элемент в массиве, и, если он равен целевому значению, возвращаем его индекс. Если же средний элемент больше целевого значения, рекурсивно выполняем бинарный поиск в левой половине массива, иначе - рекурсивно выполняем бинарный поиск в правой половине массива. Повторяем данные действия, пока не найдем целевой элемент или не определим, что его нет в массиве.

> Напоминаю, что бинарный поиск можно выполнять только в заранее отсортированном массиве.

#### Python
```python
def binary_search(array, target, low, high):
    if low > high:
        return -1

    mid = (low + high) // 2

    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return binary_search(array, target, low, mid - 1)
    else:
        return binary_search(array, target, mid + 1, high)

# Пример использования
arr = [1, 2, 4, 5, 7, 9]
target_element = 7
index = binary_search(arr, target_element, 0, len(arr) - 1)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class BinarySearch {
    public static int binarySearch(int[] array, int target, int low, int high) {
        if (low > high) {
            return -1;
        }

        int mid = (low + high) / 2;

        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            return binarySearch(array, target, low, mid - 1);
        } else {
            return binarySearch(array, target, mid + 1, high);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {1, 2, 4, 5, 7, 9};
        int targetElement = 7;
        int index = binarySearch(arr, targetElement, 0, arr.length - 1);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int binarySearch(int array[], int target, int low, int high) {
    if (low > high) {
        return -1;
    }

    int mid = (low + high) / 2;

    if (array[mid] == target) {
        return mid;
    } else if (array[mid] > target) {
        return binarySearch(array, target, low, mid - 1);
    } else {
        return binarySearch(array, target, mid + 1, high);
    }
}

// Пример использования
int main() {
    int arr[] = {1, 2, 4, 5, 7, 9};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = binarySearch(arr, targetElement, 0, size - 1);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Поиск в тексте

**Поиск в тексте** - это процесс нахождения искомой подстроки или шаблона в заданном текстовом документе или строке. Этот алгоритм широко используется в различных приложениях, включая обработку естественного языка, поиск информации, фильтрацию данных и другие.

Существуют различные алгоритмы поиска в тексте. Мы разберем алгоритмы Рабина-Карпа (Rabin-Karp) и Кнута-Морриса-Пратта (Knuth-Morris-Pratt, KMP).

**Алгоритм Рабина-Карп:**

1. Вычисление хеша шаблона и первой подстроки текста:

    - Вычисляем хеш шаблона (pattern_hash) и хеш первой подстроки текста (text_hash) с помощью выбранной хеш-функции.
    - Сравниваем pattern_hash и text_hash. Если они совпадают, выполняем дополнительную проверку, так как возможно возникновение _коллизий_.

> Коллизия - это ситуация, когда двум различным значениям или объектам соответствует одно и то же значение хеша. В контексте поиска подстроки с использованием алгоритма Рабина-Карпа, коллизия может возникнуть, когда хеши совпадают, но сами подстроки не совпадают.

> В алгоритме Рабина-Карпа, при возникновении коллизии (совпадении хеш-значений), выполняется дополнительная проверка путем сравнения подстроки с шаблоном, чтобы убедиться в наличии точного совпадения.

2. Поиск в тексте:

    - Итерируемся по тексту с позиции 0 до (n - m), где n - длина текста, m - длина шаблона.
    - Если хеши совпадают, выполняем точное сравнение подстроки с шаблоном.
    - Если совпадение найдено, выполняем необходимые действия (например, выводим индекс вхождения).

#### Python
```python
def rabin_karp(text, pattern):
    n = len(text)
    m = len(pattern)
    pattern_hash = hash(pattern)
    for i in range(n - m + 1):
        if hash(text[i:i + m]) == pattern_hash and text[i:i + m] == pattern:
            print("Pattern found at index", i)

text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
rabin_karp(text, pattern)
```
#### Java
```java
public class RabinKarpAlgorithm {
    public void rabinKarp(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        long patternHash = pattern.hashCode();
        for (int i = 0; i <= n - m; i++) {
            if (text.substring(i, i + m).hashCode() == patternHash && text.substring(i, i + m).equals(pattern)) {
                System.out.println("Pattern found at index " + i);
            }
        }
    }

    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        RabinKarpAlgorithm rabinKarp = new RabinKarpAlgorithm();
        rabinKarp.rabinKarp(text, pattern);
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void rabinKarp(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();
    size_t patternHash = hash<string>{}(pattern);
    for (int i = 0; i <= n - m; i++) {
        if (hash<string>{}(text.substr(i, m)) == patternHash && text.substr(i, m) == pattern) {
            cout << "Pattern found at index " << i << endl;
        }
    }
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";
    rabinKarp(text, pattern);
    return 0;
}
```

**Алгоритм Кнута-Морриса-Пратта (Knuth-Morris-Pratt, KMP):**

Этот алгоритм эффективно находит все вхождения заданного шаблона в текст с _линейной сложностью_.

> Линейная сложность является очень хорошим свойством алгоритма, так как время выполнения растет медленно и не зависит от размера входных данных. Это делает алгоритм KMP эффективным для поиска в тексте даже при больших объемах данных.

1. Построение префиксной таблицы:

    - Инициализируем таблицу длины шаблона (pattern) нулями.
    - Устанавливаем переменные i и j в 1.
    - Пока i < длины шаблона:
        - Если pattern[i] равен pattern[j-1]:
            - Устанавливаем таблицу[i] равной j.
            - Увеличиваем i и j на 1.
        - Иначе:
            - Если j не равно 0:
                - Устанавливаем j равной таблице[j-1].
            - Иначе:
                - Устанавливаем таблицу[i] равной 0.
                - Увеличиваем i на 1.

2. Поиск в тексте:

    - Инициализируем переменные i и j в 0.
    - Пока i < длины текста:
        - Если текст[i] равен шаблон[j]:
            - Увеличиваем i и j на 1.
            - Если j равно длине шаблона:
                - Найдено вхождение шаблона в текст. Выполняем необходимые действия (например, выводим индекс вхождения).
                - Устанавливаем j равной таблице[j-1].
        - Иначе:
            - Если j не равно 0:
                - Устанавливаем j равной таблице[j-1].
            - Иначе:
                - Увеличиваем i на 1.

#### Python
```python
def build_prefix_table(pattern):
    n = len(pattern)
    table = [0] * n
    i, j = 1, 0
    while i < n:
        if pattern[i] == pattern[j]:
            table[i] = j + 1
            i += 1
            j += 1
        else:
            if j != 0:
                j = table[j - 1]
            else:
                table[i] = 0
                i += 1
    return table

def search_pattern(text, pattern):
    n = len(text)
    m = len(pattern)
    prefix_table = build_prefix_table(pattern)
    i = j = 0
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
            if j == m:
                print("Pattern found at index", i - j)
                j = prefix_table[j - 1]
        else:
            if j != 0:
                j = prefix_table[j - 1]
            else:
                i += 1

text = "ABCABCDABABCDABCDABDE"
pattern = "ABCDABD"
search_pattern(text, pattern)
```
#### Java
```java
public class KMPAlgorithm {
    private int[] buildPrefixTable(String pattern) {
        int n = pattern.length();
        int[] table = new int[n];
        int i = 1, j = 0;
        while (i < n) {
            if (pattern.charAt(i) == pattern.charAt(j)) {
                table[i] = j + 1;
                i++;
                j++;
            } else {
                if (j != 0) {
                    j = table[j - 1];
                } else {
                    table[i] = 0;
                    i++;
                }
            }
        }
        return table;
    }

    public void searchPattern(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        int[] prefixTable = buildPrefixTable(pattern);
        int i = 0, j = 0;
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == m) {
                    System.out.println("Pattern found at index " + (i - j));
                    j = prefixTable[j - 1];
                }
            } else {
                if (j != 0) {
                    j = prefixTable[j - 1];
                } else {
                    i++;
                }
            }
        }
    }

    public static void main(String[] args) {
        String text = "ABCABCDABABCDABCDABDE";
        String pattern = "ABCDABD";
        KMPAlgorithm kmp = new KMPAlgorithm();
        kmp.searchPattern(text, pattern);
    }
}
```
#### C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> buildPrefixTable(string pattern) {
    int n = pattern.length();
    vector<int> table(n);
    int i = 1, j = 0;
    while (i < n) {
        if (pattern[i] == pattern[j]) {
            table[i] = j + 1;
            i++;
            j++;
        } else {
            if (j != 0) {
                j = table[j - 1];
            } else {
                table[i] = 0;
                i++;
            }
        }
    }
    return table;
}

void searchPattern(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();
    vector<int> prefixTable = buildPrefixTable(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
            if (j == m) {
                cout << "Pattern found at index " << (i - j) << endl;
                j = prefixTable[j - 1];
            }
        } else {
            if (j != 0) {
                j = prefixTable[j - 1];
            } else {
                i++;
            }
        }
    }
}

int main() {
    string text = "ABCABCDABABCDABCDABDE";
    string pattern = "ABCDABD";
    searchPattern(text, pattern);
    return 0;
}
```

## Поиск пути в графе

Поиск пути в графе является одной из основных задач в области алгоритмов и структур данных. Он заключается в нахождении пути между двумя вершинами графа, учитывая определенные ограничения или цели.

Существует несколько классических алгоритмов для поиска пути в графе. Ниже приведены два из них - алгоритм поиска в ширину (BFS) и алгоритм поиска в глубину (DFS).

Оба алгоритма - поиск в ширину и поиск в глубину - являются классическими методами для поиска пути в графе и могут быть применены в различных задачах, таких как поиск кратчайшего пути, определение связности графа, топологическая сортировка и другие. Выбор конкретного алгоритма зависит от требований и особенностей задачи, а также от свойств графа, в котором происходит поиск пути.

> Перед тем, как мы посмотрим на реализацию алгоритмов BFS и DFS, предлагаю разобраться что такое граф.

Граф - это абстрактная математическая структура, используемая для представления связей или отношений между объектами. Он состоит из двух основных компонентов: вершин (или узлов) и ребер (или связей).

Вершины представляют отдельные элементы или сущности, которые могут быть связаны друг с другом. Например, в графе, представляющем социальную сеть, вершины могут представлять пользователей, а ребра - связи между этими пользователями (дружба, подписка и т. д.).

> Более подробно эту структуру данных мы разберем в соответствующем разделе текущей главы. Итак, вернемся к поиску пути в графе.

**Алгоритм поиска в ширину (BFS):**

Алгоритм поиска в ширину работает путем исследования графа "в ширину". Он начинает с заданной стартовой вершины и постепенно расширяется на все соседние вершины, а затем на их соседей и так далее.

**Шаги алгоритма:**

1. Создать очередь и поместить в нее стартовую вершину.
2. Создать массив посещенных вершин и пометить стартовую вершину как посещенную.
3. Пока очередь не пуста, повторять:
    - Извлечь вершину из начала очереди.
    - Для каждого соседа этой вершины, которые еще не посещены, пометить их как посещенные и добавить в очередь.
    - Если найдена искомая вершина (целевая), завершить алгоритм.

#### Python
```python
from collections import deque

# deque является эффективной реализацией очереди, поддерживающей быстрый доступ и добавление элементов как в начало, 
# так и в конец очереди. Он имеет почти константное время выполнения для основных операций, 
# таких как добавление и удаление элементов с обоих концов.

def bfs(graph, start, end):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node == end:
            return True
        if node not in visited:
            visited.add(node)
            queue.extend(graph[node])
    return False

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

start = 'A'
end = 'F'
print(bfs(graph, start, end))
```
#### Java
```java
import java.util.*;

public class BFSSearch {
    public static boolean bfs(Map<String, List<String>> graph, String start, String end) {
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        while (!queue.isEmpty()) {
            String node = queue.poll();
            if (node.equals(end)) {
                return true;
            }
            if (!visited.contains(node)) {
                visited.add(node);
                List<String> neighbors = graph.getOrDefault(node, new ArrayList<>());
                queue.addAll(neighbors);
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Map<String, List<String>> graph = new HashMap<>();
        graph.put("A", Arrays.asList("B", "C"));
        graph.put("B", Arrays.asList("D", "E"));
        graph.put("C", Collections.singletonList("F"));
        graph.put("D", Collections.emptyList());
        graph.put("E", Collections.emptyList());
        graph.put("F", Collections.emptyList());

        String start = "A";
        String end = "F";
        System.out.println(bfs(graph, start, end));
    }
}
```
#### C++
```cpp
#include <iostream>
#include <queue>
#include <unordered_set>
#include <unordered_map>
#include <vector>
using namespace std;

bool bfs(const unordered_map<string, vector<string>>& graph, const string& start, const string& end) {
    unordered_set<string> visited;
    queue<string> q;
    q.push(start);
    while (!q.empty()) {
        string node = q.front();
        q.pop();
        if (node == end) {
            return true;
        }
        if (visited.find(node) == visited.end()) {
            visited.insert(node);
            if (graph.find(node) != graph.end()) {
                const vector<string>& neighbors = graph.at(node);
                for (const string& neighbor : neighbors) {
                    q.push(neighbor);
                }
            }
        }
    }
    return false;
}

int main() {
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"D", "E"}},
        {"C", {"F"}},
        {"D", {}},
        {"E", {}},
        {"F", {}}
    };

    string start = "A";
    string end = "F";
    cout << (bfs(graph, start, end) ? "Path found" : "Path not found") << endl;

    return 0;
}
```

Вот несколько примеров задач, для которых BFS является эффективным подходом:

1. **Поиск кратчайшего пути**: BFS может использоваться для поиска кратчайшего пути между двумя вершинами в невзвешенном графе. Он гарантирует, что найденный путь будет иметь минимальное количество ребер.
2. **Поиск всех вершин на фиксированном расстоянии**: BFS позволяет найти все вершины, находящиеся на фиксированном расстоянии от стартовой вершины. Например, можно найти все вершины, находящиеся на расстоянии 2 от исходной вершины.
3. **Поиск в ширину в графе с весами**: BFS может быть использован для поиска кратчайшего пути во взвешенном графе, если все ребра имеют одинаковый вес. В этом случае BFS будет работать аналогично поиску в невзвешенном графе.
4. **Проверка связности графа**: BFS может использоваться для проверки связности графа, то есть определения, можно ли достичь одной вершины из другой.
5. **Поиск в графе без циклов**: Если граф является ациклическим (не содержит циклов), то BFS может быть использован для поиска вершин в графе с определенными свойствами или для проверки наличия определенных путей.

**Алгоритм поиска в глубину (DFS):**

Алгоритм поиска в глубину работает путем исследования графа "в глубину". Он начинает с заданной стартовой вершины и рекурсивно исследует все смежные вершины до тех пор, пока не достигнет целевой вершины или не исследует все возможные пути.

**Шаги алгоритма:**

1. Создать массив посещенных вершин и пометить стартовую вершину как посещенную.
2. Рекурсивно для каждого соседа текущей вершины:
    - Если соседняя вершина - целевая вершина, возвратить True.
    - Если соседняя вершина еще не посещена, вызвать рекурсивно функцию dfs для этой вершины.
3. Если дошли до конца рекурсии и не найдено целевой вершины, возвратить False.

#### Python
```python
def dfs(graph, current, end, visited):
    if current == end:
        return True
    visited.add(current)
    for neighbor in graph[current]:
        if neighbor not in visited:
            if dfs(graph, neighbor, end, visited):
                return True
    return False

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

start = 'A'
end = 'F'
visited = set()
print(dfs(graph, start, end, visited))
```
#### Java
```java
import java.util.*;

public class DFSSearch {
    public static boolean dfs(Map<String, List<String>> graph, String current, String end, Set<String> visited) {
        if (current.equals(end)) {
            return true;
        }
        visited.add(current);
        List<String> neighbors = graph.getOrDefault(current, new ArrayList<>());
        for (String neighbor : neighbors) {
            if (!visited.contains(neighbor)) {
                if (dfs(graph, neighbor, end, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Map<String, List<String>> graph = new HashMap<>();
        graph.put("A", Arrays.asList("B", "C"));
        graph.put("B", Arrays.asList("D", "E"));
        graph.put("C", Collections.singletonList("F"));
        graph.put("D", Collections.emptyList());
        graph.put("E", Collections.emptyList());
        graph.put("F", Collections.emptyList());

        String start = "A";
        String end = "F";
        Set<String> visited = new HashSet<>();
        System.out.println(dfs(graph, start, end, visited));
    }
}
```
#### C++
```cpp
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
using namespace std;

bool dfs(const unordered_map<string, vector<string>>& graph, const string& current, const string& end, unordered_set<string>& visited) {
    if (current == end) {
        return true;
    }
    visited.insert(current);
    if (graph.find(current) != graph.end()) {
        const vector<string>& neighbors = graph.at(current);
        for (const string& neighbor : neighbors) {
            if (visited.find(neighbor) == visited.end()) {
                if (dfs(graph, neighbor, end, visited)) {
                    return true;
                }
            }
        }
    }
    return false;
}

int main() {
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"D", "E"}},
        {"C", {"F"}},
        {"D", {}},
        {"E", {}},
        {"F", {}}
    };

    string start = "A";
    string end = "F";
    unordered_set<string> visited;
    cout << (dfs(graph, start, end, visited) ? "Path found" : "Path not found") << endl;

    return 0;
}
```

Алгоритм поиска в глубину (DFS) часто применяется для решения следующих задач:

1. **Поиск компонент связности**: DFS позволяет найти все вершины, достижимые из данной стартовой вершины. Это полезно, когда требуется определить, насколько связный граф или сеть.
2. **Проверка наличия циклов**: DFS может использоваться для обнаружения циклов в графе. Если в процессе обхода графа обнаруживается ребро, ведущее к уже посещенной вершине (кроме предыдущей), то в графе есть цикл.
3. **Топологическая сортировка**: DFS может быть использован для топологической сортировки направленного ациклического графа (DAG). _Топологическая сортировка_ определяет линейный порядок вершин графа, такой что каждое ребро идет от левой вершины к правой. Это полезно, например, при установке зависимостей между задачами или при решении задач планирования.
4. **Генерация всех возможных путей**: DFS позволяет найти все возможные пути в графе от стартовой вершины к целевой вершине или ко всем достижимым вершинам. Это полезно, когда требуется анализировать все пути или найти оптимальный путь.
5. **Решение головоломок**: DFS может быть использован для решения различных головоломок, таких как задачи на поиск выхода из лабиринта, задачи на раскраску графа и т.д.

## Поиск наилучшего решения

Поиск наилучшего решения (или оптимального решения) является задачей нахождения наилучшего возможного решения из множества доступных вариантов. Целью является минимизация или максимизация определенного критерия или функции оценки.

Для поиска наилучшего решения могут использоваться различные алгоритмы. Один из наиболее популярных алгоритмов для этой задачи - алгоритм поиска с возвратом (backtracking). Он основан на принципе систематического перебора всех возможных вариантов и откате к предыдущему шагу при достижении невозможности продолжения.

**Шаги алгоритма поиска наилучшего решения (backtracking):**

1. Определить критерий оптимальности, то есть функцию или условие, которое определяет наилучшее решение.
2. Рекурсивно рассмотреть все возможные варианты или комбинации решений.
3. На каждом шаге проверять, удовлетворяет ли текущее решение критерию оптимальности. Если удовлетворяет, сохранить это решение.
4. Если текущее решение не удовлетворяет критерию оптимальности или уже было найдено наилучшее решение, откатиться к предыдущему шагу.
5. Повторять шаги 3-4 до исследования всех возможных вариантов.

#### Python
```python
def backtrack(candidate, input):
    if is_solution(candidate, input):
        process_solution(candidate)
        return
    
    for next_candidate in generate_candidates(candidate, input):
        if is_valid(next_candidate, candidate, input):
            make_move(next_candidate, candidate, input)
            backtrack(next_candidate, input)
            undo_move(next_candidate, candidate, input)
```
#### Java
```java
void backtrack(int[] candidate, int[] input) {
    if (isSolution(candidate, input)) {
        processSolution(candidate);
        return;
    }
    
    int[] nextCandidates = generateCandidates(candidate, input);
    for (int nextCandidate : nextCandidates) {
        if (isValid(nextCandidate, candidate, input)) {
            makeMove(nextCandidate, candidate, input);
            backtrack(nextCandidate, input);
            undoMove(nextCandidate, candidate, input);
        }
    }
}
```
#### C++
```cpp
void backtrack(vector<int>& candidate, const vector<int>& input) {
    if (isSolution(candidate, input)) {
        processSolution(candidate);
        return;
    }
    
    vector<int> nextCandidates = generateCandidates(candidate, input);
    for (int nextCandidate : nextCandidates) {
        if (isValid(nextCandidate, candidate, input)) {
            makeMove(nextCandidate, candidate, input);
            backtrack(nextCandidate, input);
            undoMove(nextCandidate, candidate, input);
        }
    }
}
```

Алгоритм поиска наилучшего решения с использованием метода backtracking является общим подходом и может быть применен в различных задачах, таких как комбинаторные задачи, задачи о раскраске, задачи о поиске маршрутов и другие.

## Графы

**Граф** - это абстрактная математическая структура, используемая для представления связей или отношений между объектами. Он состоит из двух основных компонентов: вершин (или узлов) и ребер (или связей).

**Вершины** представляют отдельные элементы или сущности, которые могут быть связаны друг с другом. Например, в графе, представляющем социальную сеть, вершины могут представлять пользователей, а ребра - связи между этими пользователями (дружба, подписка и т. д.).

**Ребра** определяют отношения или связи между вершинами. Они могут быть направленными (ориентированными), когда имеется определенное направление движения от одной вершины к другой, или неориентированными, когда связь между вершинами является двусторонней и не имеет направления.

Графы широко применяются в различных областях, таких как информатика, сетевые технологии, социальные науки, логистика и другие. Они позволяют анализировать и моделировать различные виды связей и взаимодействий между объектами.

Существуют различные типы графов в зависимости от их свойств и характеристик. **Некоторые из них включают:**

1. **Ориентированный граф:** каждое ребро имеет направление.

```
A -> B
^    |
|    v
D <- C
```

В данном примере граф содержит четыре вершины: **_A_**, **_B_**, **_C_** и **_D_**. Ребра указывают направление связи между вершинами. Например, есть ребро, идущее от вершины **_A_** к вершине **_B_**, обозначаемое стрелкой **->**. Также есть ребро, идущее от вершины **_B_** к вершине **_C_**. Из вершины **_C_** ребро идет в вершину **_D_**, а из вершины **_D_** ребро указывает обратно на вершину **_A_**.

Здесь можно заметить, что граф образует **цикл**: путь, проходящий через вершины **_A_**, **_B_**, **_C_** и **_D_**, замыкается обратно на вершину **_A_**.

2. **Неориентированный граф:** ребра не имеют направления.

```
      A
     / \
    B---C---D
    |      /
    |     /
    E----F
```

В данном примере граф содержит шесть вершин _(A, B, C, D, E, F)_ и восемь ребер, обозначенных линиями. Каждая линия представляет связь между двумя вершинами.

**Например, в графе:**

- Вершина **_A_** связана с вершинами **_B_** и **_C_**.
- Вершина **_B_** связана с вершинами **_A_** и **_C_**.
- Вершина **_C_** связана с вершинами **_A_**, **_B_**, **_D_** и **_F_**.
- Вершина **_D_** связана с вершинами **_C_** и **_F_**.
- Вершина **_E_** связана с вершиной **_F_**.
- Вершина **_F_** связана с вершинами **_C_**, **_D_** и **_E_**.

Это пример неориентированного графа, поскольку ребра не имеют направления, и связи между вершинами являются двусторонними.

3. **Взвешенный граф:** каждому ребру присвоено числовое значение (вес).

> Поскольку изобразить взвешенный граф средствами, которые я сейчас имею, достаточно проблематично, я могу предоставить вам пример представления взвешенного графа в виде списка смежности на Python. А за одно разберемся что такое **список смежностей**.

**Список смежности** - это один из способов представления графа в виде структуры данных. Он используется для хранения информации о связях между вершинами графа.

В списке смежности каждая вершина графа представляется в виде элемента списка или массива, а каждый элемент содержит список соседних вершин, с которыми данная вершина имеет ребра или связи. Таким образом, каждый элемент списка смежности представляет вершину графа и ее соседей.

**Граф:**

```
A --- B --- C
```

**Список смежности для этого графа будет выглядеть следующим образом:**

```
{
    'A': ['B'],
    'B': ['A', 'C'],
    'C': ['B']
}
```

В этом примере вершина **_A_** имеет соседа **_B_**, вершина **_B_** имеет соседей **_A_** и **_C_**, а вершина **_C_** имеет соседа **_B_**. Таким образом, список смежности позволяет легко определить, с какими вершинами связана каждая вершина графа.

> Итак, вернемся к представлению взвешенного графа.

**Представления взвешенного графа в виде списка смежности на Python:**

```Python
graph = {
    'A': [('B', 5), ('C', 2)],
    'B': [('D', 3), ('E', 7)],
    'C': [('F', 4)],
    'D': [('G', 2)],
    'E': [('H', 1)],
    'F': [],
    'G': [],
    'H': []
}
```

В данном примере граф состоит из вершин **_A_**, **_B_**, **_C_**, **_D_**, **_E_**, **_F_**, **_G_** и **_H_**. Ребра между вершинами имеют указанные веса, например, ребро между вершинами **_A_** и **_B_** имеет вес 5, ребро между вершинами **_B_** и **_D_** имеет вес 3 и так далее.

4. **Невзвешенный граф:** ребра не имеют числовых значений.

```
      A
     / \
    B---C
   / \ / \
  D---E---F
```

В этом графе есть шесть вершин, обозначенных буквами **_A_**, **_B_**, **_C_**, **_D_**, **_E_** и **_F_**. Ребра между вершинами указывают на связи между ними. Например, есть ребро между вершинами **_A_** и **_B_**, а также между **_B_** и **_C_**. Граф является неориентированным, поэтому связи между вершинами двусторонние.

5. **Связный граф:** существует путь между любыми двумя вершинами графа.

```
     A --- B
    / \   / \
   /   \ /   \
  C --- D --- E
   \   / \   /
    \ /   \ /
     F --- G
```

В этом примере граф состоит из вершин **_A_**, **_B_**, **_C_**, **_D_**, **_E_**, **_F_** и **_G_**, связанных ребрами. Все вершины графа соединены, и между любыми двумя вершинами существует путь. Это связный граф, так как нет изолированных вершин или компонентов, которые не соединены друг с другом.

6. **Дерево:** связный граф без циклов.

```
      A
    /   \
   B     C
  / \   / \
 D   E F   G
```

В данном примере **_A_** является корневой вершиной дерева, а каждая буква представляет отдельную вершину. Две вершины связаны ребром, если одна является родительской для другой. Например, **_B_** и **_C_** являются дочерними вершинами для **_A_**, **_D_** и **_E_** - для **_B_**, и так далее.

Обратите внимание, что дерево является связным графом без циклов. Каждая вершина имеет только одного родителя, кроме корневой вершины, которая не имеет родителя. 
