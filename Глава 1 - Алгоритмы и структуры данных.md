# Глава 1. Алгоритмы и структуры данных.
*Изучаем основные аглоритмы (сортировка, поиск, графы) и структуры данных (массивы, списки, стеки, очереди, деревья, хеш-таблицы).*
---
Алгоритмы являются ключевым понятием в области программирования и компьютерных наук. Они представляют собой последовательность шагов или инструкций, которые выполняются для решения определенной задачи или достижения определенной цели. Алгоритмы могут быть применены в различных областях, таких как сортировка данных, поиск информации, оптимизация задач, графические алгоритмы и многое другое.

**Основные характеристики алгоритмов:**

1. **Корректность**: Алгоритм должен решать задачу или достигать поставленной цели с правильными результатами.
2. **Эффективность**: Алгоритм должен выполняться за разумное время и использовать разумное количество ресурсов, таких как память и процессорное время.
3. **Масштабируемость**: Алгоритм должен быть способен работать с различными размерами входных данных и обрабатывать их эффективно.

**Некоторые из наиболее известных и широко используемых алгоритмов:**
- Сортировка
- Поиск
- Графы
- Динамическое программирование

## Сортировка
**Сортировка** - это процесс упорядочивания элементов в некоторой последовательности или коллекции по определенному критерию. 
Она является одной из фундаментальных операций в области алгоритмов и часто используется для улучшения эффективности поиска, 
сравнения и обработки данных. 
Сортировка имеет широкий спектр применений в различных задачах, таких как:
- Поиск наибольшего или наименьшего элемента в массиве.
- Упорядочивание данных для более эффективного поиска (например, бинарного поиска).
- Построение рейтинговых списков или таблиц.
- Обработка данных в алгоритмах машинного обучения.
- Подготовка данных для последующей обработки или анализа.
### Сортировка пузырьком (Bubble Sort)
Это, наверное, одна из самых популярных сортировок, которые многие помнят ещё со школы.
Суть проста: пары соседних элементов сравниваются и меняются местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока не будет достигнут правильный порядок. Критерии для "правильного" и "неправильного" порядка определяет разработчик. Для простоты, в данном и последующих примерах мы будем сортировать целые числа по возрастанию.
#### Python
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```
#### Java
```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```
### Сортировка выбором (Selection Sort)
На каждом шаге находится минимальный (или максимальный) элемент и меняется местами с первым неотсортированным элементом.
#### Python
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```
#### Java
```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```
### Быстрая сортировка (Quick Sort)
Выбирается опорный элемент (pivot), и элементы массива переставляются таким образом, чтобы все элементы, меньшие пивота, находились перед ним, а большие или равные - после. Процесс повторяется рекурсивно для каждой половины массива.
#### Python
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```
#### Java
```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```
### Сортировка слиянием (Merge Sort)
Эффективный алгоритм сортировки, который основывается на принципе "разделяй и сливай". Он разбивает массив на равные (или примерно равные) половины, рекурсивно сортирует каждую половину, а затем объединяет их в упорядоченный результат.

Принцип работы сортировки слиянием:

1. **Разделение**: Исходный массив рекурсивно разделяется на половины, пока каждая половина не будет состоять из одного элемента (это базовый случай).
2. **Слияние**: После разделения происходит слияние половин в упорядоченный массив. Для этого сравниваются элементы из двух половин и помещается меньший (или больший, в зависимости от порядка сортировки) элемент в результирующий массив. Этот процесс повторяется, пока все элементы не будут объединены.
3. **Возврат**: Полученный упорядоченный массив возвращается как результат сортировки.

Алгоритм сортировки слиянием можно описать следующим образом:

1. _Если размер массива меньше или равен 1, то считается, что он уже упорядочен._
2. _Разделить массив на две половины._
3. _Рекурсивно применить сортировку слиянием к каждой половине._
4. _Слить две отсортированные половины в один упорядоченный массив. Для этого сравниваются элементы из каждой половины и помещается меньший (или больший) элемент в результирующий массив. Если одна из половин закончилась, то оставшиеся элементы из другой половины просто добавляются в конец результирующего массива._
5. _Вернуть упорядоченный массив._
#### Python
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    return merge(merge_sort(left), merge_sort(right))

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
#### Java
```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for (int i = 0; i < n1; ++i) {
            L[i] = arr[left + i];
        }
        for (int j = 0; j < n2; ++j) {
            R[j] = arr[mid + 1 + j];
        }
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    int i = 0;
    int j = 0;
    int k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```
### Сортировка кучей (Heap Sort)
Создается **двоичная куча** (binary heap) из массива, а затем извлекается наибольший (или наименьший) элемент, который затем помещается в отсортированную часть массива. Процесс повторяется до полного упорядочивания.

**Двоичная куча (binary heap)** - это специальная структура данных, которая представляет собой полное двоичное дерево, удовлетворяющее основному свойству кучи. Куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева.

Основное свойство двоичной кучи (в мин-куче) заключается в том, что значение каждого узла не меньше (или не больше) значения его дочерних узлов. То есть, для любого узла i со значением A[i], узлы 2i+1 и 2i+2 (левый и правый дочерние узлы соответственно) должны иметь значения, не меньшие (или не большие) чем A[i].

*A[i] обозначает элемент массива A с индексом i*

> В контексте алгоритмов сортировки и построения кучи, A[i] обычно представляет значение элемента массива, с которым мы работаем при выполнении определенных операций, таких как сравнение или перестановка элементов.
Для простоты рассмотрим примеры с **мин-кучей**.

**Мин-куча (min-heap)** является специальным типом двоичной кучи, в которой каждый узел имеет значение, которое не меньше значений его дочерних узлов.

Основные свойства мин-кучи:

1. Свойство кучи: Значение каждого узла не меньше значений его дочерних узлов. То есть, для любого узла i со значением A[i], значения A[2i+1] (левый дочерний узел) и A[2i+2] (правый дочерний узел) не превышают A[i].
2. Полнота: Двоичная куча является полным двоичным деревом, то есть все уровни заполнены узлами, за исключением, возможно, последнего уровня, который заполняется слева направо без пропусков.

> Возможно, сейчас становится немного не понятно, поскольку мы ещё не изучили структуры данных, однако я не мог не упомянуть сортировку кучей. После изучения темы "Структуры данных", рекомендую заново прочесть о сортировке кучей.
Мин-куча обычно реализуется в виде массива, где каждый элемент массива представляет узел дерева. Нумерация элементов начинается с 0.

Пример мин-кучи:
```
        2
       / \
      4   5
     / \ 
    9   8 
```
В этом примере, значение каждого узла не меньше значений его дочерних узлов. Например, значение узла 2 не меньше значений его дочерних узлов 4 и 5. Аналогично, значение узла 4 не меньше значений его дочерних узлов 9 и 8.
Создание двоичной кучи включает в себя следующие шаги:

1. **Инициализация массива**: Создается массив, который будет представлять двоичную кучу. В этом массиве будут храниться элементы, которые необходимо упорядочить.
2. **Вставка элементов**: Элементы последовательно вставляются в массив. При вставке элемента, он сравнивается с родительским элементом и, если он меньше (или больше, в зависимости от типа кучи), то они меняются местами. Затем проверяется свойство кучи для предыдущего родительского узла, и процесс повторяется до корня дерева.
3. **Построение кучи**: После вставки всех элементов в массив, производится процедура называемая "построение кучи" (heapify). Эта процедура перестраивает массив таким образом, чтобы он удовлетворял свойству двоичной кучи. Начиная с последнего уровня дерева и двигаясь вверх, каждый узел проверяется на соответствие свойству кучи и, если это свойство нарушено, происходит перестроение кучи путем перестановки узлов.
4. **Использование кучи**: После построения кучи, наибольший (или наименьший) элемент находится в корне дерева (первый элемент массива). Этот элемент можно извлечь из кучи, а затем повторить процесс перестроения кучи для оставшихся элементов, чтобы получить следующий наибольший (или наименьший) элемент. Этот процесс можно повторять до полной сортировки массива.

#### Python
```python
def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```
#### Java
```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);
        }
    }

    public static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```
Таким образом, двоичная куча позволяет эффективно упорядочивать данные и обеспечивает быстрый доступ к наименьшему (или наибольшему) элементу. Она находит широкое применение в различных алгоритмах сортировки и приоритетных очередях.

## Поиск

Поиск является одной из основных операций в программировании и используется для нахождения определенного элемента или информации в наборе данных. Он широко применяется во множестве задач, таких как поиск элемента в массиве, нахождение определенного значения в структурах данных, фильтрация данных и многое другое.

**Некоторые примеры задач, которые можно решить с помощью поиска:**
1. **Поиск элемента в массиве**: Найти индекс элемента в заданном массиве или определить, содержится ли элемент в массиве.
2. **Бинарный поиск**: Работает для отсортированного массива и позволяет быстро находить элемент, разделяя массив на половины и исключая половину элементов на каждом шаге.
3. **Поиск в тексте**: Найти все вхождения определенного слова или подстроки в текстовом документе.
4. **Поиск пути в графе**: Найти кратчайший путь или определенный маршрут между двумя узлами в графе.
5. **Поиск наилучшего решения**: Используется в различных оптимизационных задачах, чтобы найти наилучшее решение из возможных вариантов.

### Линейный поиск

В алгоритме линейного поиска мы последовательно перебираем каждый элемент в наборе данных до тех пор, пока не найдем целевой элемент или не пройдем по всем элементам. Если элемент найден, мы возвращаем его индекс, в противном случае возвращаем _-1_, чтобы указать, что элемент не найден.

#### Python
```python
def linear_search(array, target):
    for i, element in enumerate(array):
        if element == target:
            return i
    return -1

# Пример использования
arr = [4, 2, 7, 1, 9, 5]
target_element = 7
index = linear_search(arr, target_element)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class LinearSearch {
    public static int linearSearch(int[] array, int target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == target) {
                return i;
            }
        }
        return -1;
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {4, 2, 7, 1, 9, 5};
        int targetElement = 7;
        int index = linearSearch(arr, targetElement);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int linearSearch(int array[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;
}

// Пример использования
int main() {
    int arr[] = {4, 2, 7, 1, 9, 5};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = linearSearch(arr, size, targetElement);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Бинарный поиск

При выполнении бинарного поиска, мы проверяем средний элемент в массиве, и, если он равен целевому значению, возвращаем его индекс. Если же средний элемент больше целевого значения, рекурсивно выполняем бинарный поиск в левой половине массива, иначе - рекурсивно выполняем бинарный поиск в правой половине массива. Повторяем данные действия, пока не найдем целевой элемент или не определим, что его нет в массиве.

> Напоминаю, что бинарный поиск можно выполнять только в заранее отсортированном массиве.

#### Python
```python
def binary_search(array, target, low, high):
    if low > high:
        return -1

    mid = (low + high) // 2

    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return binary_search(array, target, low, mid - 1)
    else:
        return binary_search(array, target, mid + 1, high)

# Пример использования
arr = [1, 2, 4, 5, 7, 9]
target_element = 7
index = binary_search(arr, target_element, 0, len(arr) - 1)
if index != -1:
    print(f"Элемент {target_element} найден в индексе {index}")
else:
    print("Элемент не найден")
```
#### Java
```java
public class BinarySearch {
    public static int binarySearch(int[] array, int target, int low, int high) {
        if (low > high) {
            return -1;
        }

        int mid = (low + high) / 2;

        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            return binarySearch(array, target, low, mid - 1);
        } else {
            return binarySearch(array, target, mid + 1, high);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {1, 2, 4, 5, 7, 9};
        int targetElement = 7;
        int index = binarySearch(arr, targetElement, 0, arr.length - 1);
        if (index != -1) {
            System.out.println("Элемент " + targetElement + " найден в индексе " + index);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
#### C++
```cpp
#include <iostream>
using namespace std;

int binarySearch(int array[], int target, int low, int high) {
    if (low > high) {
        return -1;
    }

    int mid = (low + high) / 2;

    if (array[mid] == target) {
        return mid;
    } else if (array[mid] > target) {
        return binarySearch(array, target, low, mid - 1);
    } else {
        return binarySearch(array, target, mid + 1, high);
    }
}

// Пример использования
int main() {
    int arr[] = {1, 2, 4, 5, 7, 9};
    int targetElement = 7;
    int size = sizeof(arr) / sizeof(arr[0]);
    int index = binarySearch(arr, targetElement, 0, size - 1);
    if (index != -1) {
        cout << "Элемент " << targetElement << " найден в индексе " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
    return 0;
}
```

### Поиск в тексте

**Поиск в тексте** - это процесс нахождения искомой подстроки или шаблона в заданном текстовом документе или строке. Этот алгоритм широко используется в различных приложениях, включая обработку естественного языка, поиск информации, фильтрацию данных и другие.

Существуют различные алгоритмы поиска в тексте. Мы разберем алгоритмы Рабина-Карпа (Rabin-Karp) и Кнута-Морриса-Пратта (Knuth-Morris-Pratt, KMP).

**Алгоритм Рабина-Карп:**

1. Вычисление хеша шаблона и первой подстроки текста:
    - Вычисляем хеш шаблона (pattern_hash) и хеш первой подстроки текста (text_hash) с помощью выбранной хеш-функции.
    - Сравниваем pattern_hash и text_hash. Если они совпадают, выполняем дополнительную проверку, так как возможно возникновение коллизий.
